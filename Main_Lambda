import requests
import os
import openai
from dotenv import load_dotenv
import json
from openai import OpenAI
import gspread
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread

#Authentication
OPENAI_API_KEY = ""
ZENDESK_API_KEY = ""

#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ'
SHEET_NAME = 'SCAutomationLog'
CREDENTIALS_FILE = 'gssecret001.json'
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):
    # Parse the incoming JSON payload
    if 'body' in event:
        body = json.loads(event['body'])
        ticket_number = body.get('ticket_number')
        print('Ticket Number:', ticket_number)
        if ticket_number is None:
            return {
                'statusCode': 400,
                'body': json.dumps('No ticket_number provided in the request body.')
            }
    else:
        return {
            'statusCode': 400,
            'body': json.dumps('No ticket_number provided in the request body.')
        }

    #Initialize variables
    global_gpt_reply = "No GPT call made"

    # Create a session and authenticate with basic auth
    session = requests.Session()
    credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
    session.headers = {
        'Authorization':  f"Basic {credentials}"
    }

    # Make a GET request to retrieve the ticket SC details
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')

    # Check if the request was successful and retrive SC data
    if response.status_code == 200:
        ticket_data_sc_list = response.json()
    else:
        print(f"Failed to fetch sc_list data: {response.status_code}")

    # Check if open SCs on the ticket are not one
    open_sc_count = sum(sc['state'] == 'open' for sc in ticket_data_sc_list['side_conversations'])
    if open_sc_count != 1:
        SC_Status = "The ticket has more than one open SC, so SC automation is not taking any steps on the ticket"
        global_gpt_reply = "No GPT call made"
    else:
        SC_Status = "One open SC was found, so SC automation will work further on the ticket"
        sc_id = ticket_data_sc_list['side_conversations'][0]['id']
        sc_list = json.dumps(ticket_data_sc_list['side_conversations'], indent=4)
        print(SC_Status)
        print('SC ID:', sc_id)
    
    # Make a GET request to retrieve the ticket SC That's Open
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')    

    # Check if the request was successful, retrive Open SC data and Clean it
    if response.status_code == 200:
        sc_data = response.json()
    else:
        print(f"Failed to fetch open sc events: {response.status_code}")

    #Identify the time of the last event in the SC
    last_response_time = sc_data['events'][-1]['created_at']
    print('Last response time:', last_response_time)

    # Initialize an empty list to hold the recipient email addresses
    recipients = []

    # Iterate through the events to find the event with the matching 'created_at' time
    for event in sc_data['events']:
        if event['created_at'] == last_response_time:

            # Add the 'from' email address to the list of recipients
            recipients.append(event['message']['from']['email'])
            
            # Iterate through the 'to' list in the message of the matching event
            for to_user in event['message']['to']:
                recipients.append(to_user['email'])
    
    # Remove Automation Sender ai-zd-integration@trilogy.com from recipients = []
    recipients = [recipient for recipient in recipients if recipient != 'ai-zd-integration@trilogy.com']

    # # Print all recipients
    # for idx, recipient in enumerate(recipients, start=1):
    #     print(f"last_response_recipient_{idx} = {recipient}")
    
    #create last_recepients as text string with all emails addresses of recipients in recipients separated by comma and a space
    last_recepients = ', '.join(recipients)
    print('Last Recipients:', last_recepients)
    
    # Make a GET request to retrieve the ticket Brand
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
    
    if response.status_code == 200:
        ticket_gen_data = response.json()
    else:
        print(f"Failed to fetch sc data: {response.status_code}")
    
    # Find the brand_id field
    brand_id = ticket_gen_data['ticket'].get('brand_id', None)
    
    #print('Brand ID:', brand_id)
    if brand_id == 360002486020:
        ticket_brand = "CallStream"
    elif brand_id == 360001065314:
        ticket_brand = "Symphony Commerce"
    elif brand_id == 8841502249362:
        ticket_brand = "Central Finance"
    elif brand_id == 360002499439:
        ticket_brand = "CityNumbers"
    else:
        ticket_brand = brand_id

    print("Ticket Brand:", ticket_brand)
    
    # Find the priority field
    ticket_priority = ticket_gen_data['ticket'].get('priority', None)
    print("Ticket Priority:", ticket_priority)
    
    if ticket_priority == 'urgent':
        default_hold_hours = 12
        
    elif ticket_priority == 'high':
        default_hold_hours = 24
        
    else:
        default_hold_hours = 72

    print("Default Hours Value Based on Ticket Priority", default_hold_hours)

    #Determine hours elapsed since the last response
    current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
    current_time_str = ''.join(current_time) # Convert the current time to a string
    last_response_time_str = ''.join(last_response_time)
    current_time_new = datetime.fromisoformat(current_time_str.replace('Z', '+00:00'))
    last_response_time_new = datetime.fromisoformat(last_response_time_str.replace('Z', '+00:00'))
    time_difference = current_time_new - last_response_time_new
    hours_elapsed = round(time_difference.total_seconds() / 3600, 2)
    print('Hours elapsed:', hours_elapsed)
    
    #### FUNCTIONS ####
    
    #Function to print actions in an internal note
    def print_action_IN(credentials, SC_Status, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
            "comment": {
                "body": "PLEASE IGNORE THIS MESSAGE. NO ACTIONS MENTIONED BELOW HAVE BEEN APPLIED. KINDLY HANDLE THE TICKET NORMALLY\n\n" + f"SC Automation: {SC_Status}\n",
                "public": False
            }
            }
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for adding IN to the ticket succeeded")
        else:
            print(f"PUT API for adding IN to the ticket failed: {response.status_code}")
    
    #Function to reply in SC
    def reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "message": {
                "body": str(sc_reply),
                "to": [
                    {"email": email} for email in recipients
                    #{ "email": "sh136708@gmail.com" },
                    #{ "email": "shfreelance@gmail.com" }
                ]
            }
        }

        response = requests.request(
            "POST",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/reply",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("POST API for sending SC succeeded")
        else:
            print(f"POST API for sending SC failed: {response.status_code}")
    
    #Function to Put the Ticket On-Hold
    def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "hold",
                "custom_fields": [
                    {"id": "360005123419", "value": str(hold_value)},
                    {"id": "360004438434", "value": str(onhold_reason)}
                ]
            }    
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        if response.status_code == 200:
            print("PUT API for putting the ticket on-hold succeeded")
        else:
            print(f"PUT API for putting the ticket on-hold failed: {response.status_code}")

    #Function to Call GPT
    def call_gpt(filename):
        #clean sc_data
        sc_data_clean = json.dumps(sc_data, indent=4)
       
        #write sc_data_clean to a json file "sc_data_output.json"
        # with open('sc_data_output.json', 'w') as f:
        #     f.write(sc_data_clean)

        data = json.loads(sc_data_clean)
        
        # Get the last message in SC Data
        def find_body_after_last_response_time(data, last_response_time):
            for event in data["events"]:
                # Check if the 'created_at' matches the target date
                if event["created_at"] == last_response_time:
                    # If a match is found, print the 'body' from the 'message'
                    return(event['message']['body'])
                    # Remove the break statement
                #else:
                    #print("No matching 'created_at' found.")
                    
        last_response_text = find_body_after_last_response_time(data, last_response_time)
        print('Last message in SC:', last_response_text)

        # Prompt GPT
        current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
        filepath = os.path.join(current_dir, filename)
        with open(filepath, 'r') as file:
            prompt = file.read().replace("last_response_text", last_response_text)
            gptresponse = client.chat.completions.create(
                model="gpt-4", #"gpt-4-turbo"
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                ],
                max_tokens=2000
            )
            gpt_reply = gptresponse.choices[0].message.content
            return gpt_reply
            #print("GPT Verdict:", gpt_reply)
    
    #Function to write to GSHEET
    def write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply):
        gc = gspread.authorize(gscredentials)
        sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
        worksheet = sh.worksheet('Sheet1')
        row_data = [current_time, ticket_number, ticket_brand, global_gpt_reply, SC_Status]
        worksheet.append_row(row_data)
    
    #Function to Make the ticket Open
    def put_ticket_on_open(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "open",
            }    
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for openning the ticket succeeded")
        else:
            print(f"PUT API for openning the ticket failed: {response.status_code}")
    
    #Function to remove esc tag
    def remove_sc_esc_tag(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {                     
                "tags": ["sc_esc"]
            }    
        }

        response = requests.request(
            "DELETE",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("DELETE API for removing sc_esc tag on the ticket succeeded")
        else:
            print(f"DELETE API for removing sc_esc tag on the ticket failed: {response.status_code}")
    
    #### LOGIC ####
    
    # Check if the last Activity in SC is a No response scenario
    if hours_elapsed > 1: # This needs to be "> 1" If the answer is Yes, then its a No response in SC scenario and following actions need to be applied.
        
        #Create a session and authenticate with basic auth
        session = requests.Session()
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        session.headers = {
            'Authorization':  f"Basic {credentials}"
        }
        
        headers = {
        "Content-Type": "application/json",
        "Authorization" : f"Basic {credentials}"
        }
        
        #Get the ticket comments
        response = requests.request(
            "GET",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments",
            headers=headers
        )
        
        # Check if the request was successful, retrive comments data and Clean it
        if response.status_code == 200:
            comments_data = response.json()
        else:
            print(f"Failed to fetch ticket comments: {response.status_code}")

        #Identify the time of the last meaningful comment in the ticket
        
        #List of author IDs to exclude. There are integeration users like Alen and CSAI that we want to exclude
        exclude_author_ids = {'1905297657594', '14181031764242', '10873686477458', '361576897454', '362463859613'}
        
        #Filtering comments to exclude those made by the specified author IDs
        filtered_comments = [comment for comment in comments_data['comments'] if str(comment['author_id']) not in exclude_author_ids]
        
        #Last Meaningful comment time
        last_comment_time = filtered_comments[-1]['created_at']
        print('Last comment time:', last_comment_time)
        
        #Determine hours elapsed since the last comment
        last_comment_time_str = ''.join(last_comment_time)
        last_comment_time_new = datetime.fromisoformat(last_comment_time_str.replace('Z', '+00:00'))
        time_difference_comment = current_time_new - last_comment_time_new
        hours_elapsed_lastcomment = round(time_difference_comment.total_seconds() / 3600, 2)
        print('Hours elapsed since last comment:', hours_elapsed_lastcomment)
    
        #If a public/private comment added in the last hour
        if hours_elapsed_lastcomment < 1:
            SC_Status = "There is no response in SC. However, a public/private comment was added in the last hour. So I am leaving the ticket open and removing the sc_esc tag"
            global_gpt_reply = "No GPT call made"
            
            #put_ticket_on_open(credentials, ticket_number)
            #remove_sc_esc_tag(credentials, ticket_number)
            
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            
        #If no public/private comment added in the last hour. This means timer opened the ticket.
        if hours_elapsed_lastcomment >= 1:
    
            if hours_elapsed < default_hold_hours: 
                hold_value = default_hold_hours
                SC_Status = f"There is no response in SC. This ticket has {ticket_priority} priority. However, it has been less than {default_hold_hours} hours since last response, so putting the ticket on hold for {default_hold_hours} hours"
                onhold_reason = f"SC Automation - No Response in SC but it has been less than {default_hold_hours} hours"
                
                #put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)

                print_action_IN(credentials, SC_Status, ticket_number)
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

            if hours_elapsed >= default_hold_hours and brand_id != 360002486020: #If hours_elapsed > default hours and it is not CallStream Support, then put the ticket on hold for hours_elapsed-12 hours with a reply in SC
                hold_value = default_hold_hours
                SC_Status = f"There is no response in SC. This ticket has {ticket_priority} priority. However, it has been {default_hold_hours} hours or more since last response, so I am sending a followup in SC and putting the ticket on hold for {default_hold_hours} hours"
                onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} or more hours - Follow up in SC"
                sc_reply = "Dear, Team\n\nWe are waiting to hear from you. Please provide an update on the same.\n\nThank you."
                
                #reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                #put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
                
                print_action_IN(credentials, SC_Status, ticket_number)
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

            #if hours_elapsed > default hours and ticket_brand = "CallStream Support":
            if hours_elapsed >= default_hold_hours and brand_id == 360002486020:
                filename = "GPT_Call_Stream_No_Response.txt"
                call_gpt(filename)
                global_gpt_reply = call_gpt(filename)
                print(global_gpt_reply)
                            
                if global_gpt_reply == "NO":
                    SC_Status = f"There is no response in SC. This is CallStream and it has been {default_hold_hours} or more hours since last response. This ticket has {ticket_priority} priority. So I engaged GPT to determine if a follow up is needed. GPT answered, NO. So I am opening this ticket for an agent to review."
                    
                    #put_ticket_on_open(credentials, ticket_number)
                    #remove_sc_esc_tag(credentials, ticket_number)
                    
                    print_action_IN(credentials, SC_Status, ticket_number)
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

                if global_gpt_reply == "YES":
                    SC_Status = f"There is no response in SC. This is CallStream and it has been {default_hold_hours} or more hours since last response. This ticket has {ticket_priority} priority. So I engaged GPT to determine if a follow up is needed. GPT answered, yes. So I am following up and putting this ticket on hold for {default_hold_hours} hours."
                    hold_value = default_hold_hours
                    onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} or more hours - CallStream Support"
                    sc_reply = "Dear, Team\n\nWe are waiting to hear from you. Please provide an update on the same.\n\nThank you."

                    #reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                    #put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
                    
                    print_action_IN(credentials, SC_Status, ticket_number)
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            
    # Check if the last Message in SC is MEANGINGLESS/MEANINGFULL 
    if hours_elapsed <= 1:
        filename = "GPT_Prompt_05.txt"
        call_gpt(filename)
        global_gpt_reply = call_gpt(filename)
        print(global_gpt_reply)

        if "MEANINGLESS" in global_gpt_reply:
            hold_value = default_hold_hours
            SC_Status = f"There is a MEANINGLESS reply in SC. I see that this ticket has {ticket_priority} priority. So, I am putting the ticket on hold for {default_hold_hours} hours"
            onhold_reason = "SC Automation - MEANINGLESS reply in SC"
            
            #put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
            
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

        if "MEANINGFUL" in global_gpt_reply:
            SC_Status = "MEANINGFUL reply in SC. Leaving the ticket open and removing the sc_esc tag"
                
            #put_ticket_on_open(credentials, ticket_number)
            #remove_sc_esc_tag(credentials, ticket_number)
            
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
