import re
import requests
import os
import openai
from dotenv import load_dotenv
from openai import OpenAI
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread
from gspread.exceptions import APIError
import json
import time
import boto3
from boto3.dynamodb.conditions import Key
from datetime import datetime, timedelta
import pytz

#Authentication

#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ'
SHEET_NAME = 'SCAutomationLog'
CREDENTIALS_FILE = 'gssecret001.json'
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):

    try:    
        ############################################################################################################       
        #### PRE INITIALIZATION ####
        ############################################################################################################    
        
        # Parse the incoming JSON payload
        if 'body' in event:
            body = json.loads(event['body'])
            ticket_number = body.get('ticket_number')
            print('Ticket Number:', ticket_number)
        else:
            raise ValueError("No ticket_number provided in the request body")
        
        #Initialize variables
        partition_key_name = 'ticket_number'
        partition_key_value = ticket_number    
        table_name = 'SC_Automan_Reruns'
        last_response_text = "No inbound message in SC. The last response time is for the first outbound reply."
        seconds_elapsed_last_outbound_sc_response = 1000
        global_gpt_reply = "No GPT call made"
        openning_comment = "" # Initial Comment about quick multi sc check
        SC_Status = "" # default comment when open sc ==1 or this becomes opening comment for multiopen  sc when open sc>1
        SC_Status_multi_append = "" # Only used for appending to the SC_List_Status in new_open_sc >1 scenario
        SC_Status_list =""
        closing_comment = "" # Closing Comment
        ticket_brand = "Not processed yet"
        ticket_status = "Not processed yet"
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        sc_subject = None
        filtered_sc_data_inbound = None
        filtered_sc_data_outbound = None
        date_time = "0000-00-00T00:00:00.000Z"
        
        #Determine Current Time
        current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
        current_time_str = ''.join(current_time) # Convert the current time to a string
        current_time_new = datetime.fromisoformat(current_time_str.strip('Z')).replace(microsecond=0)
        print('Current Time:', current_time_new)
        
        dynamodb = boto3.client(
            'dynamodb',
            aws_access_key_id=aws_access_key_id,
            aws_secret_access_key=aws_secret_access_key,
            region_name=region_name
        )
        
        ############################################################################################################       
        #### INITIAL FUNCTIONS ####
        ############################################################################################################     
        
        #Function to get the worksheet
        def get_worksheet(gscredentials):
            try:
                gc = gspread.authorize(gscredentials)
                sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
                worksheet = sh.worksheet('Sheet1')
                return worksheet
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error, ignoring writing to google sheet and moving on...")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to write to GSHEET and delete the last row
        def write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list):
            try:
                worksheet = get_worksheet(gscredentials)
                row_data = [current_time, ticket_number, ticket_brand, global_gpt_reply, SC_Status_list, ticket_status]
                worksheet.append_row(row_data)
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error, ignoring writing to google sheet and moving on...")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to Make the ticket Open
        def put_ticket_on_open(credentials, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "ticket": {
                "status": "open",
                "comment": {
                    "body": (
                        f"SC Automan: {openning_comment}\n\n{SC_Status}\n\n{SC_Status_list}\n\n{closing_comment}"
                    ),
                    "public": False
                },
                #"additional_tags": ["tempo_unsuspend"],
                "remove_tags": ["sc_esc"]
                }
            }
            
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for opening the ticket succeeded")
            else:
                print(f"PUT API for opening the ticket failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
        
        def get_last_entries(ticket_number, limit=10):
            response = dynamodb.query(
                TableName=table_name,
                KeyConditionExpression= f"{partition_key_name} = :pkval",
                ExpressionAttributeValues={
                    ':pkval': {'S': partition_key_value}
                },
                Limit=limit,
                ScanIndexForward=False,  # To get the latest entries first
                ProjectionExpression='ticket_number, date_time'  # Adjust if your attribute names are different
            )
            return response.get('Items', [])

        def is_ticket_recent(ticket_number, entries, time_limit_seconds=100):
            now = datetime.utcnow().replace(tzinfo=pytz.UTC)
            for entry in entries:
                if entry['ticket_number']['S'] == ticket_number:
                    entry_time = datetime.strptime(entry['date_time']['S'], '%Y-%m-%dT%H:%M:%S.%fZ').replace(tzinfo=pytz.UTC)
                    if (now - entry_time).total_seconds() <= time_limit_seconds:
                        return True
            return False

        def append_entry(ticket_number):
            now = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            #print(f"Adding item to DynamoDB: ticket_number={ticket_number}, date_time={now}")
            dynamodb.put_item(
                TableName=table_name,
                Item={
                    partition_key_name: {'S': partition_key_value},
                    'date_time': {'S': now}
                }
            )

        ############################################################################################################       
        #### DOUBLE RUN CHECK USING DBB WITH PRE INITIALIZATION ####
        ############################################################################################################     
        
        # Check if the ticket_number exists in the table
        try:
            response = dynamodb.get_item(
                TableName=table_name,
                Key={
                    'ticket_number': {'S': ticket_number},
                    'date_time': {'S': date_time} 
                }
            )
            # Check if the item is found
            if 'Item' in response:
                print("Successfully retrieved item from DynamoDB")
            else:
                print("No item found in DynamoDB for the given ticket_number")
        except dynamodb.exceptions.ResourceNotFoundException:
            print(f"Table {table_name} not found")
        except Exception as e:
            print(f"Error retrieving item: {e}")

        # Proceed with the double run check
        last_entries = get_last_entries('your-partition-key-value')
        if is_ticket_recent(ticket_number, last_entries):
            raise Exception(f"Multiple runs detected for ticket number {ticket_number} and stopped using DBB.")
        else:
            append_entry(ticket_number)
            print(f"Ticket number {ticket_number} has been added. Continuing script.")
        
        ############################################################################################################
        #### MAIN FUNCTIONS ####
        ############################################################################################################     
        
        # Get the last INBOUND message text in SC Data
        def find_body_for_last_response(last_sc_response_time):
            if filtered_sc_data_inbound:
                for event in filtered_sc_data_inbound["events"]: # type: ignore
                    # Check if the 'created_at' matches the target date
                    if event["created_at"] == last_sc_response_time:
                        # If a match is found, print the 'body' from the 'message'
                        return event['message']['body']
                return "No inbound message in SC. The last response time is for the first outbound reply."
            else: # If no match is found, return the specified message
                return "No inbound message in SC. The last response time is for the first outbound reply."
        
        # Get the last INBOUND message attachment status in SC Data
        def find_attachment_for_last_response(last_sc_response_time):
            if filtered_sc_data_inbound:
                for event in filtered_sc_data_inbound["events"]: # type: ignore
                    # Check if the 'created_at' matches the target date
                    if event["created_at"] == last_sc_response_time:
                        # If a match is found, print the 'body' from the 'message'
                        if event['message']['attachments']:
                            return True
                        else:
                            return False
            else: # If no match is found, return false
                return False
            
        def get_key_sc_info_light(ticket_number, sc_id, current_time_new):
            # Create a session and authenticate with basic auth
            session = requests.Session()
            session.headers = {
                'Authorization': f"Basic {credentials}"
            }

            # Make a GET request to retrieve the ticket SC That's Open
            response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')

            # Check if the request was successful, retrieve Open SC data and clean it
            if response.status_code == 200:
                sc_data = response.json()
            else:
                #print(f"Failed to fetch open sc events: {response.status_code}")
                return None, None, None, None, None, None

            # Filtering out null events
            filtered_sc_data = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and event["message"] is not None
                ]
            }

            # Is the last message inbound or outbound?
            # Get the last event from the events list
            last_event = filtered_sc_data["events"][-1]

            # Check the 'external_ids' attribute to determine if the last message is inbound or outbound
            external_ids = last_event.get("message", {}).get("external_ids", {})

            if "outboundEmail" in external_ids:
                last_message_direction = "outbound"
            elif "inboundEmail" in external_ids:
                last_message_direction = "inbound"
            else:
                last_message_direction = "unknown"

            # Filtering all outbound email events
            filtered_sc_data_outbound = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and "external_ids" in event["message"] and "outboundEmail" in event["message"]["external_ids"]
                ]
            }

            # Filtering all inbound email events
            filtered_sc_data_inbound = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and "external_ids" in event["message"] and "inboundEmail" in event["message"]["external_ids"]
                ]
            }

            # Identify the time of the last event in the SC
            if not filtered_sc_data_inbound or not filtered_sc_data_inbound["events"]:
                last_sc_response_time = filtered_sc_data_outbound["events"][0]['created_at']
            else:
                last_sc_response_time = filtered_sc_data_inbound["events"][-1]['created_at']        , 
                    
            # Determine hours elapsed since the last inbound response
            last_sc_response_time_str = ''.join(last_sc_response_time)
            last_sc_response_time_new = datetime.fromisoformat(last_sc_response_time_str.strip('Z'))
            time_difference = current_time_new - last_sc_response_time_new
            hours_elapsed_last_sc_response = round(time_difference.total_seconds() / 3600, 2) + 0.1 #to account for a few minutes delay in the status changes for the tickets and reduction in the "default hours". This becomes useful in the logic section.
            
            return (last_message_direction, hours_elapsed_last_sc_response)
            
        def get_key_sc_info(ticket_number, sc_id, current_time_new):
            # Create a session and authenticate with basic auth
            session = requests.Session()
            session.headers = {
                'Authorization': f"Basic {credentials}"
            }

            # Make a GET request to retrieve the ticket SC That's Open
            response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')

            # Check if the request was successful, retrieve Open SC data and clean it
            if response.status_code == 200:
                sc_data = response.json()
            else:
                #print(f"Failed to fetch open sc events: {response.status_code}")
                return None, None, None, None, None, None

            # Filtering out null events
            filtered_sc_data = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and event["message"] is not None
                ]
            }
            
            # Is the last message inbound or outbound?
            # Get the last event from the events list
            last_event = filtered_sc_data["events"][-1]

            # Check the 'external_ids' attribute to determine if the last message is inbound or outbound
            external_ids = last_event.get("message", {}).get("external_ids", {})

            if "outboundEmail" in external_ids:
                last_message_direction = "outbound"
            elif "inboundEmail" in external_ids:
                last_message_direction = "inbound"
            else:
                last_message_direction = "unknown"

            # Filtering all outbound email events
            filtered_sc_data_outbound = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and "external_ids" in event["message"] and "outboundEmail" in event["message"]["external_ids"]
                ]
            }

            # Filtering all inbound email events
            filtered_sc_data_inbound = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and "external_ids" in event["message"] and "inboundEmail" in event["message"]["external_ids"]
                ]
            }
                            
            # Identify the time of the last outbound event in the SC to use in Guardrail to avoid multiple replies
            last_outbound_sc_response_time = filtered_sc_data_outbound["events"][-1]['created_at']
            last_outbound_sc_response_time_str = ''.join(last_outbound_sc_response_time)
            last_outbound_sc_response_time_new = datetime.fromisoformat(last_outbound_sc_response_time_str.strip('Z'))
            seconds_elapsed_last_outbound_sc_response = (current_time_new - last_outbound_sc_response_time_new).total_seconds()
            #print('Seconds Elapsed Last Outbound Response SC:', seconds_elapsed_last_outbound_sc_response)

            # Last Outbound Response Time in SC for Safety to Prevent Multiple Replies
            SC_automation_reply_events = [
                event['created_at'] for event in filtered_sc_data_outbound["events"]
                if event.get('actor') and 'email' in event['actor'] and event['actor']['email'] == 'ai-zd-integration@trilogy.com'
            ]

            if SC_automation_reply_events:  # Check if the list is not empty
                last_outbound_response_time_SC_Automan = SC_automation_reply_events[-1]
                last_outbound_response_time_SC_Automan_str = ''.join(last_outbound_response_time_SC_Automan)
                last_outbound_response_time_SC_Automan_new = datetime.fromisoformat(last_outbound_response_time_SC_Automan_str.strip('Z'))
                seconds_elapsed_last_outbound_response_SC_Automan = (current_time_new - last_outbound_response_time_SC_Automan_new).total_seconds()
            else:
                last_outbound_response_time_SC_Automan = None
                seconds_elapsed_last_outbound_response_SC_Automan = 1000
            #print('Seconds Elapsed Last Outbound Response SC Automan:', seconds_elapsed_last_outbound_response_SC_Automan)

            # Identify the time of the last event in the SC
            if not filtered_sc_data_inbound or not filtered_sc_data_inbound["events"]:
                last_sc_response_time = filtered_sc_data_outbound["events"][0]['created_at']
            else:
                last_sc_response_time = filtered_sc_data_inbound["events"][-1]['created_at']        

            # Initialize an empty list to hold the recipient email addresses
            recipients = []

            # Iterate through the events to find the event with the matching 'created_at' time
            for event in sc_data['events']:
                if event['created_at'] == last_sc_response_time:
                    recipients.append(event['message']['from']['email'])
                    for to_user in event['message']['to']:
                        recipients.append(to_user['email'])
                    if 'cc' in event['message']:
                        for cc_user in event['message']['cc']:
                            recipients.append(cc_user['email'])

            recipients = [recipient for recipient in recipients if recipient != 'ai-zd-integration@trilogy.com']
            # last_recipients = ', '.join(recipients)
            
            #Subject of Last Message in SC That is not null
            for event in filtered_sc_data["events"][::-1]:
                if event.get("message") and event["message"].get("subject"):
                    sc_subject = event["message"]["subject"]
                    break
            #print('SC Subject:', sc_subject)

            # Determine hours elapsed since the last inbound response
            last_sc_response_time_str = ''.join(last_sc_response_time)
            last_sc_response_time_new = datetime.fromisoformat(last_sc_response_time_str.strip('Z'))
            time_difference = current_time_new - last_sc_response_time_new
            hours_elapsed_last_sc_response = round(time_difference.total_seconds() / 3600, 2) + 0.1 #to account for a few minutes delay in the status changes for the tickets and reduction in the "default hours". This becomes useful in the logic section.
            
            return (last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan, sc_subject, seconds_elapsed_last_outbound_sc_response)
        
        def reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "message": {
                    "body": str(sc_reply),
                    "to": [
                        {"email": email} for email in recipients
                        #{ "email": "sh136708@gmail.com" },
                        #{ "email": "shfreelance@gmail.com" }
                    ]
                }
            }

            response = requests.request(
                "POST",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/reply",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("POST API for sending SC succeeded")
            else:
                print(f"POST API for sending SC failed: {response.status_code}")

        def close_sc(credentials, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "side_conversation": {
                    "state":  "closed"
                }
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for closing SC succeeded")
            else:
                print(f"PUT API for closing SC failed: {response.status_code}")
        
        def open_sc(credentials, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "side_conversation": {
                    "state":  "open"
                }
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for opening SC succeeded")
            else:
                print(f"PUT API for opening SC failed: {response.status_code}")
        
        #Function to Put the Ticket On-Hold
        def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }
            
            jsonBody = {
                "ticket": {
                    "custom_fields": [
                        {"id": 360006442913, "value": "true"},
                        {"id": 360005123419, "value": str(hold_value)},
                        {"id": 360004438434, "value": str(onhold_reason)},
                        {"id": 360018492214, "value": "external_to_esw"} #"id": 360023314833
                    ],
                    "add_tags": ["alp_data_structure_link"],
                    "remove_tags": [
                        "onhold_eta_expired", "offset_added_onhold", "progress_report_no_progress", 
                        "active-chat", "atlas-ticket-custom-closure"
                    ],
                    "status": "hold",
                    "comment": {
                        "body": (
                            f"SC Automan: {openning_comment}\n\n{SC_Status}\n\n{SC_Status_list}\n\n{closing_comment}"
                        ),
                        "public": False
                    }
                }
            }
            
            #update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}"
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}" 
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for putting the ticket on-hold succeeded")
            else:
                print(f"PUT API for putting the ticket on-hold failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
                        
        #Function to Call GPT
        def call_gpt(filename):
            # Prompt GPT
            current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
            filepath = os.path.join(current_dir, filename)
            with open(filepath, 'r') as file:
                prompt = file.read().replace("last_response_text", last_response_text)
                gptresponse = client.chat.completions.create(
                    model= "gpt-4o", #"gpt-4o" "gpt-4" "gpt-4-turbo"
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant."},
                        {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                    ],
                    max_tokens=2000
                )
                gpt_reply = gptresponse.choices[0].message.content
                return gpt_reply
        
        #Function to add atlas-ticket-sc-dont-wakeup tag
        def add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {                   
                "tags": ["atlas-ticket-sc-dont-wakeup"]   
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
            else:
                print(f"PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")

        #Function to remove atlas-ticket-sc-dont-wakeup tag
        def remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {                   
                "tags": ["atlas-ticket-sc-dont-wakeup"]   
            }

            response = requests.request(
                "DELETE",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
            else:
                print(f"PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")

        ############################################################################################################        
        #### MAIN INITIALIZATION ####
        ############################################################################################################     
        
        # Create a session and authenticate with basic auth
        session = requests.Session()
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        session.headers = {
            'Authorization':  f"Basic {credentials}"
        }

        # Make a GET request to retrieve the ticket Brand and Ticket Priority
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
        
        if response.status_code == 200:
            ticket_gen_data = response.json()
        else:
            print(f"Failed to fetch sc data: {response.status_code}")
        
        # Find the brand_id field
        brand_id = ticket_gen_data['ticket'].get('brand_id', None)
        
        if brand_id == 360002486020:
            ticket_brand = "CallStream"
        elif brand_id == 360001065314:
            ticket_brand = "Symphony Commerce"
        elif brand_id == 8841502249362:
            ticket_brand = "Central Finance"
        elif brand_id == 360002499439:
            ticket_brand = "CityNumbers"
        elif brand_id == 360002231414:
            ticket_brand = "Kayako"
        else:
            ticket_brand = brand_id

        ticket_priority = ticket_gen_data['ticket'].get('priority', None)
        #print("Ticket Brand:", ticket_brand)
        #print("Ticket Priority:", ticket_priority)
        
        #Make a Get Request to get the ticket comments
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }

        response = requests.request(
            "GET",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments?sort_order=desc",
            headers=headers
        )

        # Check if the request was successful, retrieve comments data and Clean it
        if response.status_code == 200:
            comments_data = response.json()
        else:
            print(f"Failed to fetch ticket comments: {response.status_code}")

        # Find the default hold hours based on last hold or the ticket priority
        default_hold_hours = 0
        for comment in comments_data['comments']:
            if comment['author_id'] == 361576897454 and "Ticket set to ON-HOLD for" in comment['body']:
                # Extract the number of hours using regex
                match = re.search(r"Ticket set to ON-HOLD for (\d+)", comment['body'])
                if match:
                    default_hold_hours = int(match.group(1))
                    break

        if default_hold_hours == 0:
            if ticket_priority == 'urgent':
                default_hold_hours = 12
            elif ticket_priority == 'high':
                default_hold_hours = 24
            else:
                default_hold_hours = 72
        print("Default Hours Value", default_hold_hours)
        
        for comment in comments_data['comments']:
            if comment['author_id'] == 361576897454 and "It has been 10 days since we received the last reply in SC" in comment['body']:
                # Extract the number of hours using regex
                last_240hours_comment_time = comment['created_at']
                last_240hours_comment_time_str = ''.join(last_240hours_comment_time)
                last_240hours_comment_time_new = datetime.fromisoformat(last_240hours_comment_time_str.strip('Z'))
                hours_elapsed_last_240hours_comment = round((current_time_new - last_240hours_comment_time_new).total_seconds() / 3600, 2)
            else:
                last_240hours_comment_time = None
                hours_elapsed_last_240hours_comment = 0
        print('Hours elapsed since last 240 hours comment:', hours_elapsed_last_240hours_comment)
        
        #In comments_data find "Created_at" value of first comment going from top to bottom added by Author ID 14181031764242 with 3 min Text 
        for comment in comments_data['comments']:
            if comment['author_id'] == 14181031764242 and "I noticed that the most recent response in the SC was mine, less than 3 minutes ago." in comment['body']:
                last_sc_automan_3min_in_time = comment['created_at']
                last_sc_automan_3min_in_time_str = ''.join(last_sc_automan_3min_in_time)
                last_sc_automan_3min_in_time_new = datetime.fromisoformat(last_sc_automan_3min_in_time_str.strip('Z'))
                seconds_elapsed_last_sc_automan_3min_in = round((current_time_new - last_sc_automan_3min_in_time_new).total_seconds())
            else:
                last_sc_automan_3min_in_time = None
                seconds_elapsed_last_sc_automan_3min_in = 1000
        
        ##Identify the time of the last meaningful comment in the ticket
        
        #List of author IDs to exclude. There are integeration users like Alen and CSAI that we want to exclude
        exclude_author_ids = {'1905297657594', '14181031764242', '10873686477458', '361576897454', '362463859613'}
        #Filtering comments to exclude those made by the specified author IDs
        filtered_comments = [comment for comment in comments_data['comments'] if str(comment['author_id']) not in exclude_author_ids or "JiraStatusChanged" in comment['body'] or "Ticket was reopened" in comment['body']]
        
        #Last Meaningful comment time
        last_comment_time = filtered_comments[0]['created_at']
        #print('Last comment time:', last_comment_time)
        
        #Determine hours elapsed since the last comment
        last_comment_time_str = ''.join(last_comment_time)
        last_comment_time_new = datetime.fromisoformat(last_comment_time_str.strip('Z'))
        time_difference_comment = current_time_new - last_comment_time_new
        hours_elapsed_lastcomment = round(time_difference_comment.total_seconds() / 3600, 2) + 0.1 #to account for a few minutes delay in the status changes for the tickets and reduction in the "default hours". This becomes useful in the logic section. 
        print('Hours elapsed since last comment:', hours_elapsed_lastcomment)
        
        ############################################################################################################   
        #### CHECK IF REPLY WAS RECEIVED IN A CLOSED SC ####
        ############################################################################################################   
        
        # Make a GET request to retrieve the ticket SC details
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        
        # Check if the request was successful and retrive SC data
        if response.status_code == 200:
            ticket_data_sc_list = response.json()
        else:
            print(f"Failed to fetch sc_list data: {response.status_code}")

        # Check count of closed SCs on the ticket
        closed_sc_count = sum(sc['state'] == 'closed' for sc in ticket_data_sc_list['side_conversations'])
        print('Closed SC Count:', closed_sc_count)
        
        # Check if a recent response was receieved in a closed SC. If yes then open it.
        if closed_sc_count >= 1:
            closed_sc_ids = []
            closed_sc_ids = [sc['id'] for sc in ticket_data_sc_list['side_conversations'] if sc['state'] == 'closed']
            #print('Closed SC IDs:', closed_sc_ids)
            for sc_id in closed_sc_ids:  # Iterate through the open_sc_ids
                
                get_key_sc_info_light(ticket_number, sc_id, current_time_new)
                last_message_direction, hours_elapsed_last_sc_response = get_key_sc_info_light(ticket_number, sc_id, current_time_new)
                
                #print('Hours Elapsed Last SC Inbound Response:', hours_elapsed_last_sc_response)
                if last_message_direction == "inbound" and hours_elapsed_last_sc_response <0.3:
                    open_sc(credentials, sc_id, ticket_number)
                    time.sleep(2)
                    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
                    if response.status_code == 200:
                        ticket_data_sc_list = response.json()
                    else:
                        print(f"Failed to fetch sc_list data after reopening SC: {response.status_code}")
        else:
            pass
        
        ############################################################################################################
        #### QUICK PRE-CHECK FOR CLOSING OLD MULTI-SC ####
        ############################################################################################################
        
        # # Make a GET request to retrieve the ticket SC details
        # response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        
        # # Check if the request was successful and retrive SC data
        # if response.status_code == 200:
        #     ticket_data_sc_list = response.json()
        # else:
        #     print(f"Failed to fetch sc_list data: {response.status_code}")

        # # Check count of closed SCs on the ticket
        # closed_sc_count = sum(sc['state'] == 'closed' for sc in ticket_data_sc_list['side_conversations'])
        # print('Closed SC Count:', closed_sc_count)
        
        # # Check if a recent response was receieved in a closed SC. If yes then open it.
        # if closed_sc_count >= 1:
        #     closed_sc_ids = []
        #     closed_sc_ids = [sc['id'] for sc in ticket_data_sc_list['side_conversations'] if sc['state'] == 'closed']
        #     #print('Closed SC IDs:', closed_sc_ids)
        #     for sc_id in closed_sc_ids:  # Iterate through the open_sc_ids
        #         get_key_sc_info_light(ticket_number, sc_id, current_time_new)
        #         last_message_direction, hours_elapsed_last_sc_response = get_key_sc_info_light(ticket_number, sc_id, current_time_new)
        #         #print('Hours Elapsed Last SC Inbound Response:', hours_elapsed_last_sc_response)
        #         if last_message_direction == "inbound" and hours_elapsed_last_sc_response <0.3:
        #             open_sc(credentials, sc_id, ticket_number)
        #             time.sleep(2)
        #             response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        #             if response.status_code == 200:
        #                 ticket_data_sc_list = response.json()
        #             else:
        #                 print(f"Failed to fetch sc_list data after reopening SC: {response.status_code}")
        # else:
        #     pass
        
        # # Check count of open SCs on the ticket
        # open_sc_count = sum(sc['state'] == 'open' for sc in ticket_data_sc_list['side_conversations'])
        # print('Open SC Count:', open_sc_count)
        
        # if open_sc_count > 1:
        #     open_old_sc_ids = []
        #     open_sc_ids = [sc['id'] for sc in ticket_data_sc_list['side_conversations'] if sc['state'] == 'open']
        #     print('Open SC IDs:', open_sc_ids)
        #     for sc_id in open_sc_ids:  # Iterate through the open_sc_ids
        #         get_key_sc_info(ticket_number, sc_id, current_time_new)
        #         last_message_direction, hours_elapsed_last_sc_response, last_response_text, attachment_in_last_response = get_key_sc_info_medium(ticket_number, sc_id, current_time_new)
        #         #print('Hours Elapsed Last SC Inbound Response:', hours_elapsed_last_sc_response
        #         if last_message_direction == "inbound" and hours_elapsed_last_sc_response > default_hold_hours and hours_elapsed_lastcomment < default_hold_hours:
        #             filename = "GPT_Prompt_05.txt"
        #             global_gpt_reply = call_gpt(filename)
        #             #Check if the last message is meaningful
        #             if "MEANINGFUL" in global_gpt_reply:
        #                 open_old_sc_ids.append(sc_id)
        #             elif "MEANINGLESS" in global_gpt_reply and attachment_in_last_response == True:
        #                 open_old_sc_ids.append(sc_id)
        #             else:
        #                 pass
        #     print('Open Old SC IDs:', open_old_sc_ids)
        #     subject_open_old_sc = [sc['subject'] for sc in ticket_data_sc_list['side_conversations'] if sc['id'] in open_old_sc_ids]
        #     #print('Subject Open Old SC:', subject_open_old_sc)
        #     for sc_id in open_old_sc_ids:
        #         close_sc(credentials, sc_id, ticket_number)
            
        #     # Make a new GET request to retrieve the ticket SC details
        #     response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        
        #     # Check if the request was successful and retrive SC data
        #     if response.status_code == 200:
        #         new_ticket_data_sc_list = response.json()
        #     else:
        #         print(f"Failed to fetch sc_list data: {response.status_code}")
            
        #     new_open_sc_count = sum(sc['state'] == 'open' for sc in new_ticket_data_sc_list['side_conversations'])
        #     print('New Open SC Count:', new_open_sc_count)
            
        ############################################################################################################
        #### MULTI-OPEN SC HANDLING ####
        ############################################################################################################   
        
        # Make a new GET request to retrieve the ticket SC details
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')

        # Check if the request was successful and retrive SC data
        if response.status_code == 200:
            new_ticket_data_sc_list = response.json()
        else:
            print(f"Failed to fetch sc_list data: {response.status_code}")
            
        new_open_sc_count = sum(sc['state'] == 'open' for sc in new_ticket_data_sc_list['side_conversations'])
        print('New Open SC Count:', new_open_sc_count)
        new_open_sc_ids = [sc['id'] for sc in new_ticket_data_sc_list['side_conversations'] if sc['state'] == 'open']
        
        if new_open_sc_count >= 1:
            SC_Status = ""
            SC_Status_list = []
            ticket_status_list = []
            openning_comment = "\n\nI noticed we have the following open SC/s. I'm going to take a closer look..."
            
            for sc_id in new_open_sc_ids:
                last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan, sc_subject, seconds_elapsed_last_outbound_sc_response = get_key_sc_info(ticket_number, sc_id, current_time_new)
                
                #### MAIN LOGIC ####
                #Determine the last response text in SC
                last_response_text_unclipped = find_body_for_last_response(last_sc_response_time)
                #Enable this Line with a long SC reply to test Lamda exceptions by recreating exceeding token limit #last_response_text = last_response_text_unclipped
                if last_response_text_unclipped and len(last_response_text_unclipped) > 600:
                    last_response_text = last_response_text_unclipped[:600] # Clip the text to 600 characters to avoid GPT token limit
                else:
                    last_response_text = last_response_text_unclipped

                #Determine the attachment status in the last response
                attachment_in_last_response = find_attachment_for_last_response(last_sc_response_time)
                
                # print('Last message in SC:', last_response_text)
                # print('Hours Elapsed Last SC Response:', hours_elapsed_last_sc_response)
                # print('Attachment in Last Response:', attachment_in_last_response)
                
                # Check if the last Message in SC is MEANGINGLESS/MEANINGFULL
                if hours_elapsed_last_sc_response <= 0.3 and last_response_text != "No inbound message in SC. The last response time is for the first outbound reply.":
                    filename = "GPT_Prompt_05.txt"
                    global_gpt_reply = call_gpt(filename)
                    print('GPT:', global_gpt_reply)

                    if "MEANINGLESS" in global_gpt_reply:
                        if attachment_in_last_response == True:
                            SC_Status_multi_append = f"There is a seemingly meaningless reply in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). However, I have detected an attachment in it which could have additional useful infromation."
                            ticket_status = "open"
                            ticket_status_list.append(ticket_status)

                        else:
                            hold_value = default_hold_hours
                            SC_Status_multi_append = f"There is a meaningless reply in the following SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id})"
                            onhold_reason = f"SC Automation - Meaningless Response in SC, putting back on for {default_hold_hours} hours"
                            ticket_status = "hold"
                            ticket_status_list.append(ticket_status)

                    elif "MEANINGFUL" in global_gpt_reply:
                        SC_Status_multi_append = f"There is a meaningful response received in the following SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). So, I am closing it and leaving the ticket open for an agent to review manually. Please REOPEN the SC if we are following up or waiting to hear back on it again."
                        ticket_status = "open"
                        ticket_status_list.append(ticket_status)
                        close_sc(credentials, sc_id, ticket_number)
                    
                    else:
                        SC_Status_multi_append = "Something went wrong while checking things with GPT. I am leaving the ticket open for a manual review by an agent."
                        ticket_status = "open"
                        ticket_status_list.append(ticket_status)
                
                elif hours_elapsed_last_sc_response <= 0.3 and last_response_text == "No inbound message in SC. The last response time is for the first outbound reply.":
                    hold_value = default_hold_hours
                    SC_Status_multi_append = f"There is no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). It looks like we never received any response to date. Given that the last response sent by us was less than hour ago, I am putting the ticket on hold for {default_hold_hours} hours."
                    onhold_reason = f"SC Automation - No Response in SC to date, putting back on for {default_hold_hours} hours"
                    ticket_status = "hold"
                    ticket_status_list.append(ticket_status)

                # Check if the last Activity in SC is a No response scenario
                elif hours_elapsed_last_sc_response > 0.3:
                
                    # If a public/private comment added in the last few minutes
                    if hours_elapsed_lastcomment < 0.3:
                        SC_Status_multi_append = f"There is no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). However, a potentially meaningful public/private comment was added in the last few minutes."
                        global_gpt_reply = "No GPT call made"
                        ticket_status = "open"
                        ticket_status_list.append(ticket_status)
                        
                    # If no public/private comment added in the last few minutes. This means timer or something else opened the ticket.
                    elif hours_elapsed_lastcomment >= 0.3:
                        
                        # SC reply by Support Opened the ticket
                        if seconds_elapsed_last_outbound_sc_response <= 90:
                            hold_value = default_hold_hours
                            SC_Status_multi_append = f"There is no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). However, I see that we sent an outbound message in the last few minutes."
                            onhold_reason = f"SC Automation - No Response in SC, we just followed up"
                            ticket_status = "hold"
                            ticket_status_list.append(ticket_status)
                        
                        # Something unknown opened the ticket and it's been less than the default hours
                        elif hours_elapsed_last_sc_response < default_hold_hours:
                            hold_value = default_hold_hours
                            SC_Status_multi_append = f"There is no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). I do not see any valuable public or private comments added in the last few minutes nor have we sent a followup message in the SC in the last few minutes. Moreover, I see that it has been less than {default_hold_hours} hours since we last put the ticket on hold."
                            onhold_reason = f"SC Automation - No Response in SC but it has been less than {default_hold_hours} hours"
                            ticket_status = "hold"
                            ticket_status_list.append(ticket_status)
                        
                        # Timer Opened the ticket and ticket_brand  is NOT "CallStream Support" OR "CityNumbers Support"
                        elif hours_elapsed_last_sc_response >= default_hold_hours and brand_id not in (360002486020, 360002499439):
                            if hours_elapsed_last_sc_response > 240 and (hours_elapsed_last_240hours_comment == 0 or hours_elapsed_last_240hours_comment > 239):
                                SC_Status_multi_append = f"It has been 10 days since we received the last reply in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). We should review if the SC should be closed.\n"
                                ticket_status = "open"
                                ticket_status_list.append(ticket_status)
                
                            else:
                                if filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180 and seconds_elapsed_last_sc_automan_3min_in <= 180:
                                    SC_Status_multi_append = "It seems like I'm being called in a loop! So I am leaving the ticket open for a manual review by an agent.\n"
                                    ticket_status = "open"
                                    ticket_status_list.append(ticket_status)
                                    
                                elif filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180:
                                    SC_Status_multi_append = "I noticed that the most recent response in the SC was mine, less than 3 minutes ago. This was likely a Lambda double-run that can be ignored. So I am refraining from sending any more response in SC."
                                    ticket_status = "hold"
                                    ticket_status_list.append(ticket_status)
                                    onhold_reason = f"SC Automation - No Response in SC, putting back on for {default_hold_hours} hours"
                                    hold_value = default_hold_hours
                                    
                                else:
                                    hold_value = default_hold_hours
                                    SC_Status_multi_append = f"There has been no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). Since it has been {default_hold_hours} hours from the last hold, I am sending a follow-up in SC."
                                    onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - Follow up in SC"
                                    sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                                    ticket_status = "hold"
                                    ticket_status_list.append(ticket_status)
                                    add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                    reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                                    remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                    time.sleep(30)
                                
                        # Timer Opened the ticket and ticket_brand = "CallStream Support" OR "CityNumbers Support"
                        elif hours_elapsed_last_sc_response >= default_hold_hours and brand_id in (360002486020, 360002499439):

                            if hours_elapsed_last_sc_response > 240 and (hours_elapsed_last_240hours_comment == 0 or hours_elapsed_last_240hours_comment > 239):
                                SC_Status_multi_append = f"It has been 10 days since we received the last reply in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). We should review if the SC should be closed."
                                ticket_status = "open"
                                ticket_status_list.append(ticket_status)        
                            
                            else:
                                filename = "GPT_Call_Stream_No_Response.txt"
                                global_gpt_reply = call_gpt(filename)
                                print('GPT:', global_gpt_reply)
                                
                                if global_gpt_reply == "NO":
                                    SC_Status_multi_append = f"There has been no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). This is CallStream/CityNumbers and it has been {default_hold_hours} hours since the last hold. So, I engaged GPT to determine if a follow-up is needed but GPT answered, no. Therefore, we should review manually for the next steps."
                                    ticket_status = "open"
                                    ticket_status_list.append(ticket_status)

                                elif global_gpt_reply == "YES":
                                    if filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180 and seconds_elapsed_last_sc_automan_3min_in <= 180:
                                        SC_Status_multi_append = "It seems like I'm being called in a loop! So I am leaving the ticket open.\n"
                                        ticket_status = "open"
                                        ticket_status_list.append(ticket_status)
                                        
                                    elif filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180:
                                        SC_Status_multi_append = "I noticed that the most recent response in the SC was mine, less than 3 minutes ago. This was likely a Lambda double-run that can be ignored. So I am refraining from sending any more response in SC."
                                        hold_value = default_hold_hours
                                        onhold_reason = f"SC Automation - No Response in SC, putting back on for {default_hold_hours} hours"
                                        ticket_status = "hold"
                                        ticket_status_list.append(ticket_status)
                                        
                                    else:
                                        SC_Status_multi_append = f"There is no response in SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). This is CallStream/CityNumbers and it has been {default_hold_hours} hours since last hold. So I engaged GPT to determine if a follow up is needed. GPT answered, yes. Therefore, I am following up in the SC."
                                        hold_value = default_hold_hours
                                        onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - CallStream/CityNumbers Support"
                                        sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                                        ticket_status = "hold"
                                        ticket_status_list.append(ticket_status)
                                        add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                        reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                                        remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                        time.sleep(30)
                                    
                                else:
                                    SC_Status_multi_append = f"Something went wrong while checking things with GPT for the SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). I am leaving the ticket open for a manual review by an agent."
                                    ticket_status = "open"
                                    ticket_status_list.append(ticket_status)
                        
                        # Something unknown opened the ticket and Previous conditions did not satisfy
                        else:
                            SC_Status_multi_append = f"Looks like I lost track of things while checking the SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). I am leaving the ticket open for a manual review by an agent. I will watch and learn![3]"
                            ticket_status = "open"
                            ticket_status_list.append(ticket_status)
                    
                    # Something unknown opened the ticket and Previous conditions did not satisfy
                    else:
                        SC_Status_multi_append = f"Looks like I lost track of things while checking the SC: [{sc_subject}](https://central-supportdesk.zendesk.com/agent/tickets/{ticket_number}/conversations/{sc_id}). I am leaving the ticket open for a manual review by an agent. I will watch and learn![4]"
                        ticket_status = "open"
                        ticket_status_list.append(ticket_status)
                        
                # Append the SC_Status to the list
                SC_Status_list.append(SC_Status_multi_append)
            
            def clean_status_list(SC_Status_list):
                # Create a new list to hold the cleaned statuses
                cleaned_list = []
                # Iterate over each status in the list
                for status in SC_Status_list:
                    # Strip leading/trailing whitespace
                    cleaned_status = status.strip()
                    # Ensure consistent sentence spacing and capitalization
                    cleaned_status = ' '.join(cleaned_status.split())
                    cleaned_list.append(cleaned_status)
                return cleaned_list
            
            def format_status_list(cleaned_list):
                # Create a formatted string with numbering
                formatted_list = [f"• {status}" for status in cleaned_list] #formatted_list = [f"{i+1}. {status}" for i, status in enumerate(cleaned_list)]
                formatted_string = '\n\n'.join(formatted_list)
                return formatted_string

            # Clean the statuses
            cleaned_status_list = clean_status_list(SC_Status_list)

            # Format the cleaned list
            formatted_status_list = format_status_list(cleaned_status_list)
            SC_Status_list = formatted_status_list

            if "open" in ticket_status_list:
                ticket_status = "open"
                closing_comment = "\n\nGiven the above, I have put the ticket in an open state so an agent can review it manually. Please remember you can receive replies on closed SCs and reopen them anytime. Lastly, you can share improvement feedback in columns 'G', 'H' and 'I' in [SC Automan Log](https://docs.google.com/spreadsheets/d/1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ/edit?usp=sharing) which will help me learn and improve."
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
                put_ticket_on_open(credentials, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list)
                
            elif "hold" in ticket_status_list and "open" not in ticket_status_list:
                ticket_status = "hold"
                closing_comment = "\n\nGiven the above, I have put the ticket on hold."
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list)
            
            else: # ticket_status_list is empty for some werd reason.
                ticket_status = "open"
                closing_comment = "Hmm, something seems weird. I'll keep the ticket open so an agent can take a look. I'll watch and learn!"
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
                put_ticket_on_open(credentials, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list)
                
        ##############################################################################################
        #### NO OPEN SCs ####
        ##############################################################################################
        
        else: #new open_sc_count == 0:
            SC_Status = "I couldn't find an open SC, so I won't be able to proceed with the ticket."
            global_gpt_reply = "No GPT call made. No open SC found."
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
            put_ticket_on_open(credentials, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list)
            return 
    
    ##############################################################################################
    #### EXCEPTION HANDLING ####
    ##############################################################################################
    
    except Exception as e:
        if "No ticket_number provided in the request body" in str(e):
            SC_Status = "No ticket_number provided in the request body"
            print(f"{str(e)}")
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
            
        
        elif "Multiple runs detected" in str(e):
            SC_Status = "Lamda multi-run detected and stopped using DBB."
            print(f"{str(e)}")
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
            
        else:
            print(f"Lamda exception occurred on the ticket {ticket_number}: {str(e)}")
            SC_Status = "I encountered a bit of a snag! So, I am leaving the ticket open for a manual review by an agent."
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, openning_comment, closing_comment, SC_Status_list)
            put_ticket_on_open(credentials, ticket_number, SC_Status, openning_comment, closing_comment, SC_Status_list)
