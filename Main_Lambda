import re
import requests
import os
import openai
from dotenv import load_dotenv
from openai import OpenAI
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread
from gspread.exceptions import APIError
import json
import time

#Authentication
OPENAI_API_KEY = 
ZENDESK_API_KEY = 

#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ'
SHEET_NAME = 'SCAutomationLog'
CREDENTIALS_FILE = 'gssecret001.json'
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):
    try:    
        #### DOUBLE RUN CHECK ####
        
        #Initialize variables
        global_gpt_reply = "No GPT call made"
        SC_Status_0 = ""
        SC_Status = "Checking for Lamda multi-runs..."
        ticket_brand = "Not processed yet"
        ticket_status = "Not processed yet"
        last_ticket = 100
        second_last_ticket = 100
        third_last_ticket = 100
        last_run_seconds_elapsed = 1000
        second_last_run_seconds_elapsed = 1000
        third_last_run_seconds_elapsed = 1000
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        
        #Function to get the last filled row in the GSHEET
        def get_last_filled_row(worksheet):
            str_list = list(filter(None, worksheet.col_values(1)))  # Assuming column A (1) is used to determine last row
            return len(str_list)
        
        #Function to get the worksheet
        def get_worksheet(gscredentials):
            try:
                gc = gspread.authorize(gscredentials)
                sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
                worksheet = sh.worksheet('Sheet1')
                return worksheet
            except APIError as e:
                if '429' in str(e):
                    print("Quota exceeded, ignoring this error and moving on...")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to write to GSHEET without deleting the second last row
        def write_to_gsheet_no_del(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0):
            worksheet = get_worksheet(gscredentials)
            row_data = [current_time, ticket_number, ticket_brand, global_gpt_reply, SC_Status, ticket_status, SC_Status_0]
            worksheet.append_row(row_data)
        
        #Function to Delete the Last Row in GSHEET (not processed yet)      
        def delete_last_lambda_checking_rows(worksheet, ticket_number):
            # Get the total number of rows in the worksheet
            total_rows = len(worksheet.get_all_values())
            
            # If there are less than 3 rows, adjust the range to check only available rows
            check_range = min(3, total_rows)
            
            # Initialize list to store rows to delete
            rows_to_delete = []

            try:
                # Loop through the last 5 rows (or less if total rows < 5)
                for i in range(1, check_range + 1):
                    row_index = total_rows - i
                    ticket = worksheet.cell(row_index, 2).value
                    SC_Status = worksheet.cell(row_index, 5).value

                    # Check if the row matches the ticket number and the SC_Status
                    if ticket == ticket_number and SC_Status == "Checking for Lamda multi-runs...":
                        rows_to_delete.append(row_index)

                # Delete the rows marked for deletion
                for row_index in sorted(rows_to_delete, reverse=True):
                    worksheet.delete_rows(row_index)

                if not rows_to_delete:
                    print("No matching rows found to delete.")
                else:
                    print(f"Deleted rows: {', '.join(map(str, rows_to_delete))}")
            except APIError as e:
                if '429' in str(e):
                    print("Quota exceeded, ignoring this error and moving on...")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
                
        #Function to write to GSHEET and delete the last row
        def write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0):
            gc = gspread.authorize(gscredentials)
            sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
            worksheet = get_worksheet(gscredentials)
            row_data = [current_time, ticket_number, ticket_brand, global_gpt_reply, SC_Status, ticket_status, SC_Status_0]
            worksheet.append_row(row_data)
            #Delete the second last row (not processed yet) from the worksheet
            delete_last_lambda_checking_rows(worksheet, ticket_number)
            
        #Function to Make the ticket Open
        def put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "ticket": {
                "status": "open",
                "comment": {
                    "body": (
                        f"SC Automan: {SC_Status_0 if SC_Status_0 else ''}\n\n{SC_Status}\n"
                    ),
                    "public": False
                },
                "additional_tags": ["tempo_unsuspend"],
                "remove_tags": ["sc_esc"]
                }
            }
            
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for opening the ticket succeeded")
            else:
                print(f"PUT API for opening the ticket failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
        
        #Function to Calculate the Seconds Elapsed From Google Sheets For Re-Runs ONLY
        def calculate_seconds_elapsed(current_time_new, x):
            try:
                if x is None:
                    x_seconds_elapsed = 1000
                else:
                    x_new = datetime.fromisoformat(x.strip('Z')).replace(microsecond=0)
                    x_seconds_elapsed = round((current_time_new - x_new).total_seconds())
            except ValueError:
                x_seconds_elapsed = 1000
            except TypeError:
                x_seconds_elapsed = 1000
            return x_seconds_elapsed
        
        #Determine Current Time
        current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
        current_time_str = ''.join(current_time) # Convert the current time to a string
        current_time_new = datetime.fromisoformat(current_time_str.strip('Z')).replace(microsecond=0)
        print('Current Time:', current_time_new)
        
        # Parse the incoming JSON payload
        if 'body' in event:
            body = json.loads(event['body'])
            ticket_number = body.get('ticket_number')
            print('Ticket Number:', ticket_number)
            if ticket_number is None:
                return {
                    'statusCode': 400,
                    'body': json.dumps('No ticket_number provided in the request body.')
                }
        else:
            return {
                'statusCode': 400,
                'body': json.dumps('No ticket_number provided in the request body.')
            }

        # Create a connection to the Google Sheets API
        worksheet = get_worksheet(gscredentials)
        
        #Write Ticket Number and Curent Time to GSHEET
        write_to_gsheet_no_del(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
        
        #Check if the last run was for the same ticket
        last_row = get_last_filled_row(worksheet)
        
        # Fetch the last cell values (prior to the one just written above for this ticket)
        last_ticket = worksheet.cell(last_row-1, 2).value
        last_run = worksheet.cell(last_row-1, 1).value
        #last_status = worksheet.cell(last_row, 6).value
        #print ('last_ticket:', last_ticket)
        last_run_seconds_elapsed = calculate_seconds_elapsed(current_time_new, last_run)
        #print ('last_run_seconds_elapsed:', last_run_seconds_elapsed)   
        
        # Fetch the second last cell values
        second_last_ticket = worksheet.cell(last_row-2, 2).value
        second_last_run = worksheet.cell(last_row-2, 1).value
        #second_last_status = worksheet.cell(last_row-1, 6).value
        #print ('second_last_ticket:', second_last_ticket)
        second_last_run_seconds_elapsed = calculate_seconds_elapsed(current_time_new, second_last_run)
        #print ('second_last_run_seconds_elapsed:', second_last_run_seconds_elapsed)
        
        # Fetch the third last cell values
        third_last_ticket = worksheet.cell(last_row-3, 2).value
        third_last_run = worksheet.cell(last_row-3, 1).value
        #third_last_status = worksheet.cell(last_row-2, 6).value
        #print ('third_last_ticket:', third_last_ticket)
        third_last_run_seconds_elapsed = calculate_seconds_elapsed(current_time_new, third_last_run)
        #print ('third_last_run_seconds_elapsed:', third_last_run_seconds_elapsed)
        
        if ticket_number == last_ticket == second_last_ticket and -60 <= last_run_seconds_elapsed <= 60 and -60 <= second_last_run_seconds_elapsed <= 60:
            raise Exception("multi-run-loop")
        elif (ticket_number == last_ticket and -60 <= last_run_seconds_elapsed <= 60) or (ticket_number == second_last_ticket and -60 <= second_last_run_seconds_elapsed <= 60) or (ticket_number == third_last_ticket and -60 <= third_last_run_seconds_elapsed <= 60):
            raise Exception("multi-run-ticket")
        # elif (ticket_number == last_ticket and -60 <= last_run_seconds_elapsed <= 60 and last_status == "open") or (ticket_number == second_last_ticket and -60 <= second_last_run_seconds_elapsed <= 60 and second_last_status == "open") or (ticket_number == third_last_ticket and -60 <= third_last_run_seconds_elapsed <= 60 and third_last_status == "open"):
        #     raise Exception("multi-run-open")
        # elif (ticket_number == last_ticket and -60 <= last_run_seconds_elapsed <= 60 and last_status == "hold") or (ticket_number == second_last_ticket and -60 <= second_last_run_seconds_elapsed <= 60 and second_last_status == "hold") or (ticket_number == third_last_ticket and -60 <= third_last_run_seconds_elapsed <= 60 and third_last_status == "hold"):
        #     raise Exception("multi-run-hold")
        else:
            pass
        
        ############################################################################################################
        #### FUNCTIONS ####
            
        def get_key_sc_info(ticket_number, sc_id, current_time_new):
            # Create a session and authenticate with basic auth
            session = requests.Session()
            session.headers = {
                'Authorization': f"Basic {credentials}"
            }

            # Make a GET request to retrieve the ticket SC That's Open
            response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')

            # Check if the request was successful, retrieve Open SC data and clean it
            if response.status_code == 200:
                sc_data = response.json()
            else:
                #print(f"Failed to fetch open sc events: {response.status_code}")
                return None, None, None, None, None, None

            # Filtering out null events
            filtered_sc_data = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and event["message"] is not None
                ]
            }

            # Is the last message inbound or outbound?
            # Get the last event from the events list
            last_event = filtered_sc_data["events"][-1]

            # Check the 'external_ids' attribute to determine if the last message is inbound or outbound
            external_ids = last_event.get("message", {}).get("external_ids", {})

            if "outboundEmail" in external_ids:
                last_message_direction = "outbound"
            elif "inboundEmail" in external_ids:
                last_message_direction = "inbound"
            else:
                last_message_direction = "unknown"

            # Filtering all outbound email events
            filtered_sc_data_outbound = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and "external_ids" in event["message"] and "outboundEmail" in event["message"]["external_ids"]
                ]
            }

            # Filtering all inbound email events
            filtered_sc_data_inbound = {
                "events": [
                    event for event in sc_data["events"]
                    if event.get("message") and "external_ids" in event["message"] and "inboundEmail" in event["message"]["external_ids"]
                ]
            }
                            
            # Identify the time of the last outbound event in the SC to use in Guardrail to avoid multiple replies
            last_outbound_sc_response_time = filtered_sc_data_outbound["events"][-1]['created_at']
            last_outbound_sc_response_time_str = ''.join(last_outbound_sc_response_time)
            last_outbound_sc_response_time_new = datetime.fromisoformat(last_outbound_sc_response_time_str.strip('Z'))
            seconds_elapsed_last_outbound_sc_response = (current_time_new - last_outbound_sc_response_time_new).total_seconds()
            #print('Seconds Elapsed Last Outbound Response SC:', seconds_elapsed_last_outbound_sc_response)

            # Last Outbound Response Time in SC for Safety to Prevent Multiple Replies
            SC_automation_reply_events = [
                event['created_at'] for event in filtered_sc_data_outbound["events"]
                if event.get('actor') and 'email' in event['actor'] and event['actor']['email'] == 'ai-zd-integration@trilogy.com'
            ]

            if SC_automation_reply_events:  # Check if the list is not empty
                last_outbound_response_time_SC_Automan = SC_automation_reply_events[-1]
                last_outbound_response_time_SC_Automan_str = ''.join(last_outbound_response_time_SC_Automan)
                last_outbound_response_time_SC_Automan_new = datetime.fromisoformat(last_outbound_response_time_SC_Automan_str.strip('Z'))
                seconds_elapsed_last_outbound_response_SC_Automan = (current_time_new - last_outbound_response_time_SC_Automan_new).total_seconds()
            else:
                last_outbound_response_time_SC_Automan = None
                seconds_elapsed_last_outbound_response_SC_Automan = 1000
            #print('Seconds Elapsed Last Outbound Response SC Automan:', seconds_elapsed_last_outbound_response_SC_Automan)

            # Identify the time of the last event in the SC
            if not filtered_sc_data_inbound or not filtered_sc_data_inbound["events"]:
                last_sc_response_time = filtered_sc_data_outbound["events"][0]['created_at']
            else:
                last_sc_response_time = filtered_sc_data_inbound["events"][-1]['created_at']        

            # Initialize an empty list to hold the recipient email addresses
            recipients = []

            # Iterate through the events to find the event with the matching 'created_at' time
            for event in sc_data['events']:
                if event['created_at'] == last_sc_response_time:
                    recipients.append(event['message']['from']['email'])
                    for to_user in event['message']['to']:
                        recipients.append(to_user['email'])
                    if 'cc' in event['message']:
                        for cc_user in event['message']['cc']:
                            recipients.append(cc_user['email'])

            recipients = [recipient for recipient in recipients if recipient != 'ai-zd-integration@trilogy.com']
            # last_recipients = ', '.join(recipients)

            # Determine hours elapsed since the last inbound response
            last_sc_response_time_str = ''.join(last_sc_response_time)
            last_sc_response_time_new = datetime.fromisoformat(last_sc_response_time_str.strip('Z'))
            time_difference = current_time_new - last_sc_response_time_new
            hours_elapsed_last_sc_response = round(time_difference.total_seconds() / 3600, 2) + 0.1 #to account for a few minutes delay in the status changes for the tickets and reduction in the "default hours". This becomes useful in the logic section.
            return (last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan)
        
        def reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "message": {
                    "body": str(sc_reply),
                    "to": [
                        {"email": email} for email in recipients
                        #{ "email": "sh136708@gmail.com" },
                        #{ "email": "shfreelance@gmail.com" }
                    ]
                }
            }

            response = requests.request(
                "POST",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/reply",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("POST API for sending SC succeeded")
            else:
                print(f"POST API for sending SC failed: {response.status_code}")

        def close_sc(credentials, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "side_conversation": {
                    "state":  "closed"
                }
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for closing SC succeeded")
            else:
                print(f"PUT API for closing SC failed: {response.status_code}")
        
        def open_sc(credentials, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {
                "side_conversation": {
                    "state":  "open"
                }
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for opening SC succeeded")
            else:
                print(f"PUT API for opening SC failed: {response.status_code}")
        
        #Function to Put the Ticket On-Hold
        def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number,SC_Status, SC_Status_0):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }
            
            jsonBody = {
                "ticket": {
                    "custom_fields": [
                        {"id": 360006442913, "value": "true"},
                        {"id": 360005123419, "value": str(hold_value)},
                        {"id": 360004438434, "value": str(onhold_reason)},
                        {"id": 360018492214, "value": "external_to_esw"} #"id": 360023314833
                    ],
                    "add_tags": ["alp_data_structure_link"],
                    "remove_tags": [
                        "onhold_eta_expired", "offset_added_onhold", "progress_report_no_progress", 
                        "active-chat", "atlas-ticket-custom-closure"
                    ],
                    "status": "hold",
                    "comment": {
                        "body": (
                            f"SC Automan: {SC_Status_0 if SC_Status_0 else ''}\n\n{SC_Status}\n"
                        ),
                        "public": False
                    }
                }
            }
            
            #update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}"
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}" 
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                pass
                #print("PUT API for putting the ticket on-hold succeeded")
            else:
                print(f"PUT API for putting the ticket on-hold failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")

        # Get the last INBOUND message text in SC Data
        def find_body_for_last_response(last_sc_response_time):
            if filtered_sc_data_inbound:
                for event in filtered_sc_data_inbound["events"]: # type: ignore
                    # Check if the 'created_at' matches the target date
                    if event["created_at"] == last_sc_response_time:
                        # If a match is found, print the 'body' from the 'message'
                        return event['message']['body']
                return "No inbound message in SC. The last response time is for the first outbound reply."
            else: # If no match is found, return the specified message
                return "No inbound message in SC. The last response time is for the first outbound reply."
        
        # Get the last INBOUND message attachment status in SC Data
        def find_attachment_for_last_response(last_sc_response_time):
            if filtered_sc_data_inbound:
                for event in filtered_sc_data_inbound["events"]: # type: ignore
                    # Check if the 'created_at' matches the target date
                    if event["created_at"] == last_sc_response_time:
                        # If a match is found, print the 'body' from the 'message'
                        if event['message']['attachments']:
                            return True
                        else:
                            return False
            else: # If no match is found, return false
                return False
                        
        #Function to Call GPT
        def call_gpt(filename):
            #clean sc_data
            #sc_data_clean = json.dumps(sc_data, indent=4)
        
            #write sc_data_clean to a json file "sc_data_output.json"
            # with open('sc_data_output.json', 'w') as f:
            #     f.write(sc_data_clean)

            #data = json.loads(sc_data_clean)

            # Prompt GPT
            current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
            filepath = os.path.join(current_dir, filename)
            with open(filepath, 'r') as file:
                prompt = file.read().replace("last_response_text", last_response_text)
                gptresponse = client.chat.completions.create(
                    model= "gpt-4o", #"gpt-4o" "gpt-4" "gpt-4-turbo"
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant."},
                        {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                    ],
                    max_tokens=2000
                )
                gpt_reply = gptresponse.choices[0].message.content
                return gpt_reply
        
        #Function to add atlas-ticket-sc-dont-wakeup tag
        def add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {                   
                "tags": ["atlas-ticket-sc-dont-wakeup"]   
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
            else:
                print(f"PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")

        #Function to remove atlas-ticket-sc-dont-wakeup tag
        def remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }

            jsonBody = {                   
                "tags": ["atlas-ticket-sc-dont-wakeup"]   
            }

            response = requests.request(
                "DELETE",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                pass
                #print("PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
            else:
                print(f"PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")

        ############################################################################################################        
        #### MAIN INITIALIZATION ####
        
        #Initialize variables
        last_response_text = "No inbound message in SC. The last response time is for the first outbound reply."
        seconds_elapsed_last_outbound_sc_response = 1000
        
        # Create a session and authenticate with basic auth
        session = requests.Session()
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        session.headers = {
            'Authorization':  f"Basic {credentials}"
        }

        # Make a GET request to retrieve the ticket Brand and Ticket Priority
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
        
        if response.status_code == 200:
            ticket_gen_data = response.json()
        else:
            print(f"Failed to fetch sc data: {response.status_code}")
        
        # Find the brand_id field
        brand_id = ticket_gen_data['ticket'].get('brand_id', None)
        
        if brand_id == 360002486020:
            ticket_brand = "CallStream"
        elif brand_id == 360001065314:
            ticket_brand = "Symphony Commerce"
        elif brand_id == 8841502249362:
            ticket_brand = "Central Finance"
        elif brand_id == 360002499439:
            ticket_brand = "CityNumbers"
        elif brand_id == 360002231414:
            ticket_brand = "Kayako"
        else:
            ticket_brand = brand_id

        ticket_priority = ticket_gen_data['ticket'].get('priority', None)
        #print("Ticket Brand:", ticket_brand)
        #print("Ticket Priority:", ticket_priority)
        
        #Make a Get Request to get the ticket comments
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }

        response = requests.request(
            "GET",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments?sort_order=desc",
            headers=headers
        )

        # Check if the request was successful, retrieve comments data and Clean it
        if response.status_code == 200:
            comments_data = response.json()
        else:
            print(f"Failed to fetch ticket comments: {response.status_code}")

        # Find the default hold hours based on last hold or the ticket priority
        default_hold_hours = 0
        for comment in comments_data['comments']:
            if comment['author_id'] == 361576897454 and "Ticket set to ON-HOLD for" in comment['body']:
                # Extract the number of hours using regex
                match = re.search(r"Ticket set to ON-HOLD for (\d+)", comment['body'])
                if match:
                    default_hold_hours = int(match.group(1))
                    break

        if default_hold_hours == 0:
            if ticket_priority == 'urgent':
                default_hold_hours = 12
            elif ticket_priority == 'high':
                default_hold_hours = 24
            else:
                default_hold_hours = 72
        print("Default Hours Value", default_hold_hours)
        
        for comment in comments_data['comments']:
            if comment['author_id'] == 361576897454 and "It has been 10 days since we received the last reply in SC." in comment['body']:
                # Extract the number of hours using regex
                last_240hours_comment_time = comment['created_at']
                last_240hours_comment_time_str = ''.join(last_240hours_comment_time)
                last_240hours_comment_time_new = datetime.fromisoformat(last_240hours_comment_time_str.strip('Z'))
                hours_elapsed_last_240hours_comment = round((current_time_new - last_240hours_comment_time_new).total_seconds() / 3600, 2)
            else:
                last_240hours_comment_time = None
                hours_elapsed_last_240hours_comment = 0
        print('Hours elapsed since last 240 hours comment:', hours_elapsed_last_240hours_comment)
        
        #In comments_data find "Created_at" value of first comment going from top to bottom added by Author ID 14181031764242 with 3 min Text 
        for comment in comments_data['comments']:
            if comment['author_id'] == 14181031764242 and "I noticed that the most recent response in the SC was mine, less than 3 minutes ago." in comment['body']:
                last_sc_automan_3min_in_time = comment['created_at']
                last_sc_automan_3min_in_time_str = ''.join(last_sc_automan_3min_in_time)
                last_sc_automan_3min_in_time_new = datetime.fromisoformat(last_sc_automan_3min_in_time_str.strip('Z'))
                seconds_elapsed_last_sc_automan_3min_in = round((current_time_new - last_sc_automan_3min_in_time_new).total_seconds())
            else:
                last_sc_automan_3min_in_time = None
                seconds_elapsed_last_sc_automan_3min_in = 1000
        
        ##Identify the time of the last meaningful comment in the ticket
        
        #List of author IDs to exclude. There are integeration users like Alen and CSAI that we want to exclude
        exclude_author_ids = {'1905297657594', '14181031764242', '10873686477458', '361576897454', '362463859613'}
        #Filtering comments to exclude those made by the specified author IDs
        filtered_comments = [comment for comment in comments_data['comments'] if str(comment['author_id']) not in exclude_author_ids or "JiraStatusChanged" in comment['body'] or "Ticket was reopened" in comment['body']]
        
        #Last Meaningful comment time
        last_comment_time = filtered_comments[0]['created_at']
        #print('Last comment time:', last_comment_time)
        
        #Determine hours elapsed since the last comment
        last_comment_time_str = ''.join(last_comment_time)
        last_comment_time_new = datetime.fromisoformat(last_comment_time_str.strip('Z'))
        #print('Last comment time_new:', last_comment_time_new)
        time_difference_comment = current_time_new - last_comment_time_new
        #print('current_time_new:', current_time_new)
        #print('Time difference:', time_difference_comment)
        hours_elapsed_lastcomment = round(time_difference_comment.total_seconds() / 3600, 2) + 0.1 #to account for a few minutes delay in the status changes for the tickets and reduction in the "default hours". This becomes useful in the logic section. 
        print('Hours elapsed since last comment:', hours_elapsed_lastcomment)
        
        #### PRE-CHECK FOR MULTI-SC ####
        
        # Make a GET request to retrieve the ticket SC details
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        
        # Check if the request was successful and retrive SC data
        if response.status_code == 200:
            ticket_data_sc_list = response.json()
        else:
            print(f"Failed to fetch sc_list data: {response.status_code}")

        # Check count of closed SCs on the ticket
        closed_sc_count = sum(sc['state'] == 'closed' for sc in ticket_data_sc_list['side_conversations'])
        print('Closed SC Count:', closed_sc_count)
        
        # Check if a recent response was receieved in a closed SC. If yes then open it.
        if closed_sc_count >= 1:
            closed_sc_ids = []
            closed_sc_ids = [sc['id'] for sc in ticket_data_sc_list['side_conversations'] if sc['state'] == 'closed']
            #print('Closed SC IDs:', closed_sc_ids)
            for sc_id in closed_sc_ids:  # Iterate through the open_sc_ids
                get_key_sc_info(ticket_number, sc_id, current_time_new)
                last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan = get_key_sc_info(ticket_number, sc_id, current_time_new)
                #print('Hours Elapsed Last SC Inbound Response:', hours_elapsed_last_sc_response)
                if last_message_direction == "inbound" and hours_elapsed_last_sc_response <0.3:
                    open_sc(credentials, sc_id, ticket_number)
        else:
            pass
        
        # Check count of open SCs on the ticket
        open_sc_count = sum(sc['state'] == 'open' for sc in ticket_data_sc_list['side_conversations'])
        print('Open SC Count:', open_sc_count)
        
        if open_sc_count > 1:
            open_old_sc_ids = []
            open_sc_ids = [sc['id'] for sc in ticket_data_sc_list['side_conversations'] if sc['state'] == 'open']
            print('Open SC IDs:', open_sc_ids)
            for sc_id in open_sc_ids:  # Iterate through the open_sc_ids
                get_key_sc_info(ticket_number, sc_id, current_time_new)
                last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan = get_key_sc_info(ticket_number, sc_id, current_time_new)
                #print('Hours Elapsed Last SC Inbound Response:', hours_elapsed_last_sc_response)
                if last_message_direction == "inbound" and hours_elapsed_last_sc_response > default_hold_hours and hours_elapsed_lastcomment < default_hold_hours:
                    open_old_sc_ids.append(sc_id)
            print('Open Old SC IDs:', open_old_sc_ids)
            subject_open_old_sc = [sc['subject'] for sc in ticket_data_sc_list['side_conversations'] if sc['id'] in open_old_sc_ids]
            #print('Subject Open Old SC:', subject_open_old_sc)
            for sc_id in open_old_sc_ids:
                close_sc(credentials, sc_id, ticket_number)
            
            # Make a new GET request to retrieve the ticket SC details
            response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        
            # Check if the request was successful and retrive SC data
            if response.status_code == 200:
                new_ticket_data_sc_list = response.json()
            else:
                print(f"Failed to fetch sc_list data: {response.status_code}")
            
            new_open_sc_count = sum(sc['state'] == 'open' for sc in new_ticket_data_sc_list['side_conversations'])
            print('New Open SC Count:', new_open_sc_count)
            
            if new_open_sc_count != open_sc_count:
                if new_open_sc_count >1:
                    SC_Status = ""
                    SC_Status_0 = (
                        f"I have closed the following SCs where more than {default_hold_hours} hours have passed since we last heard from them. Additionally, we have worked on the ticket since and chose not to reply to the last message. So I assume we are not waiting to hear back for anything else in them:\n\n"
                        + "\n".join([f"Subject: {subject}" for subject in subject_open_old_sc])
                        + "\n\n"
                        + "I see we still have more than one open SC. I will leave the ticket open for an agent to review my actions. Moreover, please know that you can reopen any closed SC and can continue to receive replies to it!\n\n"
                    )
                    global_gpt_reply = "No GPT call made. More than one open SC found."
                    ticket_status = "open"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                    # Add MULTI Open SC Handling
                    return #exit()
                    
                elif new_open_sc_count ==1:
                    SC_Status = ""
                    SC_Status_0 = (
                        f"I have closed the following SCs where more than {default_hold_hours} hours have passed since we last heard from them. Additionally, we have worked on the ticket since and chose not to reply to the last message. So I assume we are not waiting to hear back for anything else in them:\n\n"
                        + "\n".join([f"Subject: {subject}" for subject in subject_open_old_sc])
                        + "\n\n"
                        + "Furthermore, I see we now have one open SC. So, I will work further...\n\n"
                    )
                    sc_id = [sc['id'] for sc in new_ticket_data_sc_list['side_conversations'] if sc['state'] == 'open'][0]
                    last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan = get_key_sc_info(ticket_number, sc_id, current_time_new)
                    pass

                else: # new_open_sc_count < 1 or == 0:
                    SC_Status = ""
                    SC_Status_0 = ("No open SC was found, so I will not work further on the ticket. I will leave the ticket open for an agent to review.")
                    global_gpt_reply = "No GPT call made. More than one open SC found."
                    ticket_status = "open"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                    return #exit()
                    
            elif new_open_sc_count == open_sc_count:
                SC_Status = "The ticket has multiple open SCs, and I'm not sure if any of them can be closed. So, I'm keeping the ticket open for an agent to review and decide if any unnecessary SCs can be closed. Also, please note that you can still receive responses to closed SCs and you can reopen any closed SC at any time."
                global_gpt_reply = "No GPT call made. More than one open SC found. "
                ticket_status = "open"
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                # Add MULTI Open SC Handling
                return #exit()
            
        elif open_sc_count == 1:
            SC_Status = "SC Automan: One open SC was found, so I will work further on the ticket"
            sc_id = ticket_data_sc_list['side_conversations'][0]['id']
            #sc_list = json.dumps(ticket_data_sc_list['side_conversations'], indent=4)
            #print(SC_Status)
            print('SC ID:', sc_id)
            last_message_direction, hours_elapsed_last_sc_response, recipients, last_sc_response_time, filtered_sc_data_inbound, filtered_sc_data_outbound, seconds_elapsed_last_outbound_response_SC_Automan = get_key_sc_info(ticket_number, sc_id, current_time_new)
            print('Last SC Response Time:', last_sc_response_time)
            
        else: #open_sc_count == 0:
            SC_Status = "No open SC was found, so I will not work further on the ticket"
            global_gpt_reply = "No GPT call made. No open SC found."
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
            return #exit()
        
        
        ############################################################################################################
        #### LAST SC RESPONSE TEXT and Attachment Status ####
        
        #Determine the last response text in SC
        last_response_text_unclipped = find_body_for_last_response(last_sc_response_time)
        #Enable this Line with a long SC reply to test Lamda exceptions by recreating exceeding token limit #last_response_text = last_response_text_unclipped
        if last_response_text_unclipped and len(last_response_text_unclipped) > 600:
            last_response_text = last_response_text_unclipped[:600] # Clip the text to 600 characters to avoid GPT token limit
        else:
            last_response_text = last_response_text_unclipped
        print('Last message in SC:', last_response_text)
        attachment_in_last_response = find_attachment_for_last_response(last_sc_response_time)
        print('Attachment in Last Response:', attachment_in_last_response)
        
        
        ############################################################################################################
        #### MAIN LOGIC ####
        
        print('Hours Elapsed Last SC Response:', hours_elapsed_last_sc_response)
        
        # Check if the last Message in SC is MEANGINGLESS/MEANINGFULL 
        if hours_elapsed_last_sc_response <= 0.3 and last_response_text != "No inbound message in SC. The last response time is for the first outbound reply.":
            filename = "GPT_Prompt_05.txt"
            global_gpt_reply = call_gpt(filename)
            print('GPT:', global_gpt_reply)

            if "MEANINGLESS" in global_gpt_reply:
                if attachment_in_last_response == True:
                    SC_Status = "There is a seemingly meaningless reply in SC. However, since I have detected an attachment in it, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                    ticket_status = "open"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                else:
                    hold_value = default_hold_hours
                    SC_Status = f"There is a meaningless reply in SC. I see that this ticket has {ticket_priority} priority. Given the previous history, I am putting the ticket on hold for {default_hold_hours} hours."
                    onhold_reason = f"SC Automation - Meaningless Response in SC, putting back on for {default_hold_hours} hours"
                    ticket_status = "hold"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)

            elif "MEANINGFUL" in global_gpt_reply:
                SC_Status = "There is a meaningful reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                ticket_status = "open"
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
            
            else:
                SC_Status = "Something went wrong while chekcing things with GPT. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                ticket_status = "open"
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
        
        elif hours_elapsed_last_sc_response <= 0.3 and last_response_text == "No inbound message in SC. The last response time is for the first outbound reply.":
            hold_value = default_hold_hours
            SC_Status = f"There is no response in SC and it looks like we never received any response to date. Given that the last response sent by us was less than hour ago, I am putting the ticket on hold for {default_hold_hours} hours."
            onhold_reason = f"SC Automation - No Response in SC to date, putting back on for {default_hold_hours} hours"
            ticket_status = "hold"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)

        # Check if the last Activity in SC is a No response scenario
        elif hours_elapsed_last_sc_response > 0.3:
        
            # If a public/private comment added in the last few minutes
            if hours_elapsed_lastcomment < 0.3:
                SC_Status = "There is no response in SC. However, a potentially meaningful public/private comment was added in the last few minutes. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                global_gpt_reply = "No GPT call made"
                ticket_status = "open"        
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                
            # If no public/private comment added in the last few minutes. This means timer or something else opened the ticket.
            elif hours_elapsed_lastcomment >= 0.3:
                
                # SC reply by Support Opened the ticket
                if seconds_elapsed_last_outbound_sc_response <= 90:
                    hold_value = default_hold_hours
                    SC_Status = f"There is no response in SC. However, I see that we sent an outbound message in the last few minutes. So, I am deciding to put the ticket on hold for another {default_hold_hours} hours."
                    onhold_reason = f"SC Automation - No Response in SC, we just followed up"
                    ticket_status = "hold"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)
                
                # Something unknown opened the ticket and it's been less than the default hours
                elif hours_elapsed_last_sc_response < default_hold_hours:
                    hold_value = default_hold_hours
                    SC_Status = f"There is no response in SC and I do not see any valuable public or private comments added in the last few minutes nor have we sent a followup message in the SC in the last few minutes. However, since it has been less than {default_hold_hours} hours as previously put on hold. So, I am deciding to put the ticket on hold for another {default_hold_hours} hours."
                    onhold_reason = f"SC Automation - No Response in SC but it has been less than {default_hold_hours} hours"
                    ticket_status = "hold"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)
                
                # Timer Opened the ticket and ticket_brand  is NOT "CallStream Support" OR "CityNumbers Support"
                elif hours_elapsed_last_sc_response >= default_hold_hours and (brand_id != 360002486020 or brand_id != 360002499439):
                    if hours_elapsed_last_sc_response > 240 and (hours_elapsed_last_240hours_comment == 0 or hours_elapsed_last_240hours_comment > 239):
                        SC_Status = "It has been 10 days since we received the last reply in SC. So, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent to see if the SC or the ticket should be closed."
                        ticket_status = "open"
                        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                        put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                    else:
                        if filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180 and seconds_elapsed_last_sc_automan_3min_in <= 180:
                            SC_Status = "It seems like I'm being called in a loop! So I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                            ticket_status = "open"
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                            
                        elif filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180:
                            SC_Status = "I noticed that the most recent response in the SC was mine, less than 3 minutes ago. This was likely a Lambda double-run that can be ignored. So I am refraining from sending any more response in SC and putting the ticket on-hold without a reply. Cheers!"
                            ticket_status = "hold"
                            onhold_reason = f"SC Automation - No Response in SC, putting back on for {default_hold_hours} hours"
                            hold_value = default_hold_hours
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)
                            
                        else:
                            hold_value = default_hold_hours
                            SC_Status = f"There has been no response in SC since the last hold of {default_hold_hours} hours. Therefore, I am sending a follow-up in SC and putting the ticket on hold for another {default_hold_hours} hours."
                            onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - Follow up in SC"
                            sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                            ticket_status = "hold"
                            add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                            reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                            remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                            time.sleep(30)
                            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)

                # Timer Opened the ticket and ticket_brand = "CallStream Support" OR "CityNumbers Support"
                elif hours_elapsed_last_sc_response >= default_hold_hours and (brand_id == 360002486020 or brand_id == 360002499439):

                    if hours_elapsed_last_sc_response > 240 and (hours_elapsed_last_240hours_comment == 0 or hours_elapsed_last_240hours_comment > 239):
                        SC_Status = "It has been 10 days since we received the last reply in SC. So, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent to see if the SC or the ticket should be closed."
                        ticket_status = "open"            
                        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                        put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                    
                    else:
                        filename = "GPT_Call_Stream_No_Response.txt"
                        global_gpt_reply = call_gpt(filename)
                        print('GPT:', global_gpt_reply)
                        
                        if global_gpt_reply == "NO":
                            SC_Status = f"There has been no response in SC. This is CallStream/CityNumbers and it has been {default_hold_hours} hours since the last hold. I also noticed that this ticket has {ticket_priority} priority. So, I engaged GPT to determine if a follow-up is needed but GPT answered, no. Therefore, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                            ticket_status = "open"
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)

                        elif global_gpt_reply == "YES":
                            if filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180 and seconds_elapsed_last_sc_automan_3min_in <= 180:
                                SC_Status = "It seems like I'm being called in a loop! So I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                                ticket_status = "open"
                                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                                put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                                
                            elif filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180:
                                SC_Status = "I noticed that the most recent response in the SC was mine, less than 3 minutes ago. This was likely a Lambda double-run that can be ignored. So I am refraining from sending any more response in SC and putting the ticket on-hold without a reply. Cheers!"
                                hold_value = default_hold_hours
                                onhold_reason = f"SC Automation - No Response in SC, putting back on for {default_hold_hours} hours"
                                ticket_status = "hold"
                                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)
                                
                            else:
                                SC_Status = f"There is no response in SC. This is CallStream/CityNumbers and it has been {default_hold_hours} hours since last hold. So I engaged GPT to determine if a follow up is needed. GPT answered, yes. Therefore, I am following up in SC and putting this ticket on hold for another {default_hold_hours} hours."
                                hold_value = default_hold_hours
                                onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - CallStream/CityNumbers Support"
                                sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                                ticket_status = "hold"
                                add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                                remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                                time.sleep(30)
                                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status, SC_Status_0)
                        else:
                            SC_Status = "Something went wrong while chekcing things with GPT. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                            ticket_status = "open"
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
                
                # Something unknown opened the ticket and Previous conditions did not satisfy
                else:
                    SC_Status = "I am not sure what caused this ticket to become open. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent. I will watch and learn![1]"
                    ticket_status = "open"
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                    put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
            
            # Something unknown opened the ticket and Previous conditions did not satisfy
            else:
                SC_Status = "I am not sure what caused this ticket to become open. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent. I will watch and learn![2]"
                ticket_status = "open"
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
                put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
        
        # Something unknown opened the ticket and Previous conditions did not satisfy
        else:
            SC_Status = "I am not sure what caused this ticket to become open. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent. I will watch and learn![3]"
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
    
    ############################################################################################################
    #### EXCEPTION HANDLING ####
    
    except Exception as e:
        if "multi-run-ticket" in str(e):
            SC_Status = "Lamda multi-run detected and stopped."
            print(f"Multi-run on ticket {ticket_number} stopped: {str(e)}")
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            
        # if "multi-run-open" in str(e):
        #     print(f"Multi-run on open ticket {ticket_number} stopped: {str(e)}")
            # SC_Status = "I was called again in less than 60 seconds for the same ticket. This sometimes happens due to a double-run on the AWS and can be ignored. Once again, I am putting the ticket on open, removing the sc_esc tag and adding the tempo_unsuspend tag."
            # ticket_status = "open"
            # write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            # put_ticket_on_open(credentials, ticket_number,SC_Status)
            
        # elif "multi-run-hold" in str(e):
        #     print(f"Multi-run on on-hold ticket {ticket_number} stopped: {str(e)}")
            # SC_Status = "I was called again in less than 60 seconds for the same ticket. This sometimes happens due to a double-run on the AWS and can be ignored. I am putting the ticket on hold, again. Cheers!"
            # hold_value = default_hold_hours
            # onhold_reason = f"SC Automation - Putting back on for {default_hold_hours} hours"
            # ticket_status = "hold"
            # write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            # put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)
            
        elif "multi-run-loop" in str(e):
            print(f"Multi-run-loop on a the ticket {ticket_number} stopped: {str(e)}")
            SC_Status = "I am being called in a loop. If I am unable to stop it, I will leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
            
        else:
            print(f"Lamda exception occurred on the ticket {ticket_number}: {str(e)}")
            SC_Status = "I encountered a bit of a snag! So, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
            ticket_status = "open"
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply, ticket_status, SC_Status_0)
            put_ticket_on_open(credentials, ticket_number, SC_Status, SC_Status_0)
