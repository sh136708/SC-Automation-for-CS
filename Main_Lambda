import requests
import os
import openai
from dotenv import load_dotenv
import json
from openai import OpenAI
import gspread
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread

#Authentication
OPENAI_API_KEY = ""
ZENDESK_API_KEY = ""

#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ'
SHEET_NAME = 'SCAutomationLog'
CREDENTIALS_FILE = '.\gssecret001.json'
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):
    # Parse the incoming JSON payload
    if 'body' in event:
        body = json.loads(event['body'])
        ticket_number = body.get('ticket_number')
        if ticket_number is None:
            return {
                'statusCode': 400,
                'body': json.dumps('No ticket_number provided in the request body.')
            }
    else:
        return {
            'statusCode': 400,
            'body': json.dumps('No ticket_number provided in the request body.')
        }

    #Initialize variables
    global_gpt_reply = "None"

    # Create a session and authenticate with basic auth
    session = requests.Session()
    credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
    session.headers = {
        'Authorization':  f"Basic {credentials}"
    }

    # Make a GET request to retrieve the ticket SC details
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')

    # Check if the request was successful and retrive SC data
    if response.status_code == 200:
        ticket_data_sc_list = response.json()
    else:
        print(f"Failed to fetch data: {response.status_code}")

    # Check if open SCs on the ticket are not one
    open_sc_count = sum(sc['state'] == 'open' for sc in ticket_data_sc_list['side_conversations'])
    if open_sc_count != 1:
        SC_Status = "One open SC is not equal to one, so SC automation is not taking any steps on the ticket"
        global_gpt_reply = "No GPT call made"
    else:
        SC_Status = "One open SC was found, so SC automation will work further on the ticket"
        sc_id = ticket_data_sc_list['side_conversations'][0]['id']
        sc_list = json.dumps(ticket_data_sc_list['side_conversations'], indent=4)
        print('SC ID:', sc_id)
    
    # Make a GET request to retrieve the ticket SC That's Open
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')    

    # Check if the request was successful, retrive Open SC data and Clean it
    if response.status_code == 200:
        sc_data = response.json()
    else:
        print(f"Failed to fetch sc data: {response.status_code}")

    #Identify the time of the last event in the SC
    last_response_time = sc_data['events'][-1]['created_at']
    print('Last response time:', last_response_time)

    # Initialize an empty list to hold the recipient email addresses
    recipients = []

    # Iterate through the events to find the event with the matching 'created_at' time
    for event in sc_data['events']:
        if event['created_at'] == last_response_time:

            # Add the 'from' email address to the list of recipients
            recipients.append(event['message']['from']['email'])
            
            # Iterate through the 'to' list in the message of the matching event
            for to_user in event['message']['to']:
                recipients.append(to_user['email'])
    
    # Remove Automation Sender ai-zd-integration@trilogy.com from recipients = []
    recipients = [recipient for recipient in recipients if recipient != 'ai-zd-integration@trilogy.com']

    # # Print all recipients
    # for idx, recipient in enumerate(recipients, start=1):
    #     print(f"last_response_recipient_{idx} = {recipient}")
    
    #create last_recepients as text string with all emails addresses of recipients in recipients separated by comma and a space
    last_recepients = ', '.join(recipients)
    print('Last Recipients:', last_recepients)
    
    # Make a GET request to retrieve the ticket Brand
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
    
    if response.status_code == 200:
        ticket_gen_data = response.json()
        # Find the brand_id field
        brand_id = ticket_gen_data['ticket'].get('brand_id', None)
        # Set the value of ticket_brand
        ticket_brand = brand_id #Call Stream brand ID 360002486020 #Symphony Call ID is 360001065314
        
        print("Ticket Brand:", ticket_brand)
    else:
        print(f"Failed to fetch sc data: {response.status_code}")

    #Determine hours elapsed since the last response
    current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
    current_time_str = ''.join(current_time) # Convert the current time to a string
    last_response_time_str = ''.join(last_response_time)
    current_time_new = datetime.fromisoformat(current_time_str.replace('Z', '+00:00'))
    last_response_time_new = datetime.fromisoformat(last_response_time_str.replace('Z', '+00:00'))
    time_difference = current_time_new - last_response_time_new
    hours_elapsed = 0 #round(time_difference.total_seconds() / 3600)
    print('Hours elapsed:', hours_elapsed)

    # Hard coded the default hold hours
    default_hold_hours = 72; # This needs to be 72 hours

    #Function to put the ticket on hold
    def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "hold",
                "custom_fields": [
                    {"id": "360005123419", "value": str(hold_value)},
                    {"id": "360004438434", "value": str(onhold_reason)}
                ],
                #"tags": ["apply_hold_macro"]
            }    
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )
    
    # Function to print actions in an internal note
    def print_action_IN(credentials, SC_Status, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "comment": {
                    "body": f"SC Automation: {SC_Status}\n",
                    "public": False
                }
            }
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )    
    
    # Function to reply in SC
    def reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "message": {
                "body": str(sc_reply),
                "to": [
                    {"email": email} for email in recipients
                    #{ "email": "sh136708@gmail.com" },
                    #{ "email": "shfreelance@gmail.com" }
                ]
            }
        }

        response = requests.request(
            "POST",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/reply",
            headers=headers,
            data=json.dumps(jsonBody)
        )
    
    #Put the Ticket On-Hold
    def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "hold",
                "custom_fields": [
                    {"id": "360005123419", "value": str(hold_value)},
                    {"id": "360004438434", "value": str(onhold_reason)}
                ],
                #"tags": ["apply_hold_macro"]
            }    
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )

    #Call GPT
    def call_gpt(filename):
        #clean sc_data
        sc_data_clean = json.dumps(sc_data, indent=4)
       
        #write sc_data_clean to a json file "sc_data_output.json"
        with open('sc_data_output.json', 'w') as f:
            f.write(sc_data_clean)

        data = json.loads(sc_data_clean)
        
        # Get the last message in SC Data
        def find_preview_text_after_last_response_time(data, last_response_time):
            for event in data["events"]:
                # Check if the 'created_at' matches the target date
                if event["created_at"] == last_response_time:
                    # If a match is found, print the 'preview_text' from the 'message'
                    return(event['message']['preview_text'])
                    # Remove the break statement
                else:
                    print("No matching 'created_at' found.")
        
        last_response_text = find_preview_text_after_last_response_time(data, last_response_time)
        print('Last message in SC:', last_response_text)

        # Prompt GPT
        current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
        filepath = os.path.join(current_dir, filename)
        with open(filepath, 'r') as file:
            prompt = file.read().replace("last_response_text", last_response_text)
            gptresponse = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                ],
                max_tokens=100
            )
            gpt_reply = gptresponse.choices[0].message.content
            return gpt_reply
            #print("GPT Verdict:", gpt_reply)
    
    #Function to write to GSHEET
    def write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply):
        gc = gspread.authorize(gscredentials)
        sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
        worksheet = sh.worksheet('Sheet1')
        row_data = [current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply]
        worksheet.append_row(row_data)
    
    # Check if the last Activity in SC is a No response scenario
    if hours_elapsed > 1: # This needs to be "> 1" If the answer is Yes, then its a No response in SC scenario and following actions need to be applied.
        if hours_elapsed < default_hold_hours: # If it has not been 72 hours since the last response, put ticket on Hold for hours_elapsed+12 hours without a reply in SC
            hold_value = default_hold_hours + 12;
            SC_Status = "No response in SC. However, it has been less than 72 hours since last resposne, so putting the ticket on hold for 72+ hours"
            onhold_reason = "SC Automation - No Response in SC in less than 72 hours"

            print_action_IN(credentials, SC_Status, ticket_number)
            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

        if hours_elapsed > default_hold_hours and ticket_brand != 360002486020: #If hours_elapsed > 72 and it is not CallStream Support, then put the ticket on hold for hours_elapsed-12 hours without a reply in SC
            hold_value = default_hold_hours - 12;
            SC_Status = "No response in SC. However, it has been MORE than 72 hours since last resposne, so I am sending a Followup in SC and putting the ticket on hold for 72- hours"
            onhold_reason = "SC Automation - No Response in SC in more than 72 hours - Follow up in SC"
            sc_reply = "Dear, Team\n\nWe are waiting to hear from you. Please provide an update on the same.\n\nThank you."
            
            reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
            print_action_IN(credentials, SC_Status, ticket_number)
            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

        #if hours_elapsed > 72 and ticket_brand = "CallStream Support":
        if hours_elapsed > default_hold_hours and ticket_brand == 360002486020:
            filename = "GPT_Call_Stream_No_Response.txt"
            call_gpt(filename)
            global_gpt_reply = call_gpt(filename)
            print(global_gpt_reply)
                        
            if global_gpt_reply == "NO":
                SC_Status = "No response in SC. This is callStream and it has been MORE than 72 hours since last response, so I engaged GPT to determine if a follow up is needed. GPT answered, no. So I am closing this ticket."
                print_action_IN(credentials, SC_Status, ticket_number)
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                #close the ticket
                headers = {
                    "Content-Type": "application/json",
                    "Authorization" : f"Basic {credentials}"
                }

                jsonBody = {
                    "ticket": {
                        "status": "solved"
                    }    
                }

                response = requests.request(
                    "PUT",
                    f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
                    headers=headers,
                    data=json.dumps(jsonBody)
                )
                

            if global_gpt_reply == "YES":
                SC_Status = "No response in SC. This is callStream and it has been MORE than 72 hours since last response, so I engaged GPT to determine if a follow up is needed. GPT answered, yes. So I am following up and putting this ticket on hold for 72- hours."
                hold_value = default_hold_hours - 12;
                onhold_reason = "SC Automation - No Response in SC in more than 72 hours - CallStream Support"
                sc_reply = "Dear, Team\n\nWe are waiting to hear from you. Please provide an update on the same.\n\nThank you."

                reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                print_action_IN(credentials, SC_Status, ticket_number)
                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            
    # Check if the last Message in SC is MEANGINGLESS/MEANINGFULL 
    if hours_elapsed < 1:
        filename = "GPT_Prompt_05.txt"
        call_gpt(filename)
        global_gpt_reply = call_gpt(filename)
        print(global_gpt_reply)

        if "MEANINGLESS" in global_gpt_reply:
            hold_value = default_hold_hours + 12;
            SC_Status = "MEANINGLESS reply in SC. Putting the ticket on hold for 72 hours"
            onhold_reason = "SC Automation - MEANINGLESS reply in SC"
            
            print_action_IN(credentials, SC_Status, ticket_number)
            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

        if "MEANINGFUL" in global_gpt_reply:
            SC_Status = "MEANINGFUL reply in SC. Leaving the ticket open and removing the sc_esc tag"
                        
            def put_ticket_on_open(credentials, ticket_number):
                headers = {
                    "Content-Type": "application/json",
                    "Authorization" : f"Basic {credentials}"
                }

                jsonBody = {
                    "ticket": {
                        "status": "open",
                        #"tags": ["apply_hold_macro"]
                    }    
                }

                response = requests.request(
                    "PUT",
                    f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
                    headers=headers,
                    data=json.dumps(jsonBody)
                )
                
            put_ticket_on_open(credentials, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

            def remove_sc_esc_tag(credentials, ticket_number):
                headers = {
                    "Content-Type": "application/json",
                    "Authorization" : f"Basic {credentials}"
                }

                jsonBody = {
                    "ticket": {                     
                        "tags": ["sc_esc"]
                    }    
                }

                response = requests.request(
                    "DELETE",
                    f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                    headers=headers,
                    data=json.dumps(jsonBody)
                )

            remove_sc_esc_tag(credentials, ticket_number)
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)

# Assuming this is for demonstration purposes outside AWS Lambda
if __name__ == "__main__":
    event = {
        "body": json.dumps({"ticket_number": "4318902"})
    }
    context = {}
    lambda_handler(event, context)
