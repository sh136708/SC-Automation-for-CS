import re
import requests
import os
import openai
from dotenv import load_dotenv
import json
from openai import OpenAI
import gspread
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread

#Authentication
OPENAI_API_KEY = 
ZENDESK_API_KEY = 

#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ'
SHEET_NAME = 'SCAutomationLog'
CREDENTIALS_FILE = 'gssecret001.json'
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):
    # Parse the incoming JSON payload
    if 'body' in event:
        body = json.loads(event['body'])
        ticket_number = body.get('ticket_number')
        print('Ticket Number:', ticket_number)
        if ticket_number is None:
            return {
                'statusCode': 400,
                'body': json.dumps('No ticket_number provided in the request body.')
            }
    else:
        return {
            'statusCode': 400,
            'body': json.dumps('No ticket_number provided in the request body.')
        }

    #Initialize variables
    global_gpt_reply = "No GPT call made"

    # Create a session and authenticate with basic auth
    session = requests.Session()
    credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
    session.headers = {
        'Authorization':  f"Basic {credentials}"
    }
    
    # Make a GET request to retrieve the ticket SC details
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')

    # Check if the request was successful and retrive SC data
    if response.status_code == 200:
        ticket_data_sc_list = response.json()
    else:
        print(f"Failed to fetch sc_list data: {response.status_code}")

    # Check if open SCs on the ticket are not one
    open_sc_count = sum(sc['state'] == 'open' for sc in ticket_data_sc_list['side_conversations'])
    if open_sc_count != 1:
        SC_Status = "SC Automan: The ticket has more than one open SC, so I am not taking any steps on the ticket"
        global_gpt_reply = "No GPT call made"
    else:
        SC_Status = "SC Automan: One open SC was found, so I will work further on the ticket"
        sc_id = ticket_data_sc_list['side_conversations'][0]['id']
        sc_list = json.dumps(ticket_data_sc_list['side_conversations'], indent=4)
        print(SC_Status)
        print('SC ID:', sc_id)
    
    # Make a GET request to retrieve the ticket SC That's Open
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')    

    # Check if the request was successful, retrive Open SC data and Clean it
    if response.status_code == 200:
        sc_data = response.json()
    else:
        print(f"Failed to fetch open sc events: {response.status_code}")

    # Filtering out all outbound email events So we are only looking at inbound emails in SC
    filtered_sc_data_outbound = {"events": [event for event in sc_data["events"] if "outboundEmail" in event["message"]["external_ids"]]}
    filtered_sc_data = {"events": [event for event in sc_data["events"] if "inboundEmail" in event["message"]["external_ids"]]}

    # Identify the time of the last event in the SC
    if not filtered_sc_data or not filtered_sc_data["events"]:
        last_response_time = filtered_sc_data_outbound["events"][-1]['created_at']
    else:
        last_response_time = filtered_sc_data["events"][-1]['created_at']
    print('Last response time:', last_response_time)

    # Initialize an empty list to hold the recipient email addresses
    recipients = []

    # Iterate through the events to find the event with the matching 'created_at' time
    for event in sc_data['events']:
        if event['created_at'] == last_response_time:

            # Add the 'from' email address to the list of recipients
            recipients.append(event['message']['from']['email'])
            
            # Iterate through the 'to' list in the message of the matching event
            for to_user in event['message']['to']:
                recipients.append(to_user['email'])
    
    # Remove Automation Sender ai-zd-integration@trilogy.com from recipients = []
    recipients = [recipient for recipient in recipients if recipient != 'ai-zd-integration@trilogy.com']

    # # Print all recipients
    # for idx, recipient in enumerate(recipients, start=1):
    #     print(f"last_response_recipient_{idx} = {recipient}")
    
    #create last_recepients as text string with all emails addresses of recipients in recipients separated by comma and a space
    last_recepients = ', '.join(recipients)
    print('Last Recipients:', last_recepients)
    
    # Make a GET request to retrieve the ticket Brand and Ticket Priority
    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
    
    if response.status_code == 200:
        ticket_gen_data = response.json()
    else:
        print(f"Failed to fetch sc data: {response.status_code}")
    
    # Find the brand_id field
    brand_id = ticket_gen_data['ticket'].get('brand_id', None)
    
    #print('Brand ID:', brand_id)
    if brand_id == 360002486020:
        ticket_brand = "CallStream"
    elif brand_id == 360001065314:
        ticket_brand = "Symphony Commerce"
    elif brand_id == 8841502249362:
        ticket_brand = "Central Finance"
    elif brand_id == 360002499439:
        ticket_brand = "CityNumbers"
    else:
        ticket_brand = brand_id

    print("Ticket Brand:", ticket_brand)

    # Find the priority field
    ticket_priority = ticket_gen_data['ticket'].get('priority', None)
    print("Ticket Priority:", ticket_priority)

    #Determine hours elapsed since the last response
    current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
    current_time_str = ''.join(current_time) # Convert the current time to a string
    last_response_time_str = ''.join(last_response_time)
    current_time_new = datetime.fromisoformat(current_time_str.strip('Z'))
    last_response_time_new = datetime.fromisoformat(last_response_time_str.strip('Z'))
    time_difference = current_time_new - last_response_time_new
    hours_elapsed = round(time_difference.total_seconds() / 3600, 2)
    print('Hours elapsed:', hours_elapsed)
    
    #Make a Get Request to get the ticket comments
    headers = {
        "Content-Type": "application/json",
        "Authorization" : f"Basic {credentials}"
    }

    response = requests.request(
        "GET",
        f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments?sort_order=desc",
        headers=headers
    )

    # Check if the request was successful, retrieve comments data and Clean it
    if response.status_code == 200:
        comments_data = response.json()
    else:
        print(f"Failed to fetch ticket comments: {response.status_code}")

    # Find the default hold hours based on last hold or the ticket priority
    default_hold_hours = 0
    for comment in comments_data['comments']:
        if comment['author_id'] == 361576897454 and "Ticket set to ON-HOLD for" in comment['body']:
            # Extract the number of hours using regex
            match = re.search(r"Ticket set to ON-HOLD for (\d+)", comment['body'])
            if match:
                default_hold_hours = int(match.group(1))
                break

    if default_hold_hours == 0:
        if ticket_priority == 'urgent':
            default_hold_hours = 12
        elif ticket_priority == 'high':
            default_hold_hours = 24
        else:
            default_hold_hours = 72

    print("Default Hours Value", default_hold_hours)
    
    #Identify the time of the last meaningful comment in the ticket
    #List of author IDs to exclude. There are integeration users like Alen and CSAI that we want to exclude
    exclude_author_ids = {'1905297657594', '14181031764242', '10873686477458', '361576897454', '362463859613'}
    #Filtering comments to exclude those made by the specified author IDs
    filtered_comments = [comment for comment in comments_data['comments'] if str(comment['author_id']) not in exclude_author_ids or "JiraStatusChanged" in comment['body'] or "Ticket was reopened" in comment['body']]
    
    #Last Meaningful comment time
    last_comment_time = filtered_comments[0]['created_at']
    print('Last comment time:', last_comment_time)
    
    #Determine hours elapsed since the last comment
    last_comment_time_str = ''.join(last_comment_time)
    last_comment_time_new = datetime.fromisoformat(last_comment_time_str.strip('Z'))
    print('Last comment time_new:', last_comment_time_new)
    time_difference_comment = current_time_new - last_comment_time_new
    print('current_time_new:', current_time_new)
    print('Time difference:', time_difference_comment)
    hours_elapsed_lastcomment = round(time_difference_comment.total_seconds() / 3600, 2)
    print('Hours elapsed since last comment:', hours_elapsed_lastcomment)
    
    #### FUNCTIONS ####
    
    #Function to print actions in an internal note
    def print_action_IN(credentials, SC_Status, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
            "comment": {
                "body": f"SC Automan: {SC_Status}\n",
                "public": False
            }
            }
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for adding IN to the ticket succeeded")
        else:
            print(f"PUT API for adding IN to the ticket failed: {response.status_code}")
    
    #Function to reply in SC
    def reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "message": {
                "body": str(sc_reply),
                "to": [
                    {"email": email} for email in recipients
                    #{ "email": "sh136708@gmail.com" },
                    #{ "email": "shfreelance@gmail.com" }
                ]
            }
        }

        response = requests.request(
            "POST",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/reply",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("POST API for sending SC succeeded")
        else:
            print(f"POST API for sending SC failed: {response.status_code}")
    
    #Function to Put the Ticket On-Hold
    def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }
        
        jsonBody = {
            "ticket": {
                "custom_fields": [
                    {"id": 360006442913, "value": "true"},
                    {"id": 360005123419, "value": str(hold_value)},
                    {"id": 360004438434, "value": str(onhold_reason)}
                ],
                "add_tags": ["alp_data_structure_link"],
                "remove_tags": [
                    "onhold_eta_expired", "offset_added_onhold", "progress_report_no_progress", 
                    "active-chat", "atlas-ticket-custom-closure"
                ],
                "status": "hold",
                "comment": {
                    "public": False
                }
            }
        }
        
        update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}"
        update_response = requests.put(update_url, headers=headers, json=jsonBody)
        
        if update_response.status_code == 200:
            print("PUT API for putting the ticket on-hold succeeded")
        else:
            print(f"PUT API for putting the ticket on-hold failed: {update_response.status_code}")
            print(f"Response content: {update_response.content}")

    #Function to Call GPT
    def call_gpt(filename):
        #clean sc_data
        sc_data_clean = json.dumps(sc_data, indent=4)
       
        #write sc_data_clean to a json file "sc_data_output.json"
        # with open('sc_data_output.json', 'w') as f:
        #     f.write(sc_data_clean)

        data = json.loads(sc_data_clean)
        
        # Get the last message in SC Data
        def find_body_after_last_response_time(data, last_response_time):
            for event in data["events"]:
                # Check if the 'created_at' matches the target date
                if event["created_at"] == last_response_time:
                    # If a match is found, print the 'body' from the 'message'
                    return(event['message']['body'])
                    # Remove the break statement
                #else:
                    #print("No matching 'created_at' found.")
                    
        last_response_text = find_body_after_last_response_time(data, last_response_time)
        print('Last message in SC:', last_response_text)

        # Prompt GPT
        current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
        filepath = os.path.join(current_dir, filename)
        with open(filepath, 'r') as file:
            prompt = file.read().replace("last_response_text", last_response_text)
            gptresponse = client.chat.completions.create(
                model="gpt-4", #"gpt-4-turbo"
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                ],
                max_tokens=2000
            )
            gpt_reply = gptresponse.choices[0].message.content
            return gpt_reply
            #print("GPT Verdict:", gpt_reply)
    
    #Function to write to GSHEET
    def write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply):
        gc = gspread.authorize(gscredentials)
        sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
        worksheet = sh.worksheet('Sheet1')
        row_data = [current_time, ticket_number, ticket_brand, global_gpt_reply, SC_Status]
        worksheet.append_row(row_data)
    
    #Function to Make the ticket Open
    def put_ticket_on_open(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "open",
            }    
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for openning the ticket succeeded")
        else:
            print(f"PUT API for openning the ticket failed: {response.status_code}")
    
    #Function to remove esc tag
    def remove_sc_esc_tag(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {                   
            "tags": ["sc_esc"]   
        }

        response = requests.request(
            "DELETE",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("DELETE API for removing sc_esc tag on the ticket succeeded")
        else:
            print(f"DELETE API for removing sc_esc tag on the ticket failed: {response.status_code}")
        
    #Function to add tempo suspend tag
    def add_tempo_unsuspend_tag(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {                   
            "tags": ["tempo_unsuspend"]   
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for adding tempo_unsuspend tag on the ticket succeeded")
        else:
            print(f"PUT API for adding tempo_unsuspend tag on the ticket failed: {response.status_code}")
    
    #Function to add atlas-ticket-sc-dont-wakeup tag
    def add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {                   
            "tags": ["atlas-ticket-sc-dont-wakeup"]   
        }

        response = requests.request(
            "PUT",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
        else:
            print(f"PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")

    #Function to remove atlas-ticket-sc-dont-wakeup tag
    def remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        jsonBody = {                   
            "tags": ["atlas-ticket-sc-dont-wakeup"]   
        }

        response = requests.request(
            "DELETE",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
            headers=headers,
            data=json.dumps(jsonBody)
        )
        
        if response.status_code == 200:
            print("PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
        else:
            print(f"PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")
    
    #### LOGIC ####
    
    # Check if the last Activity in SC is a No response scenario
    if hours_elapsed > 1: # This needs to be "> 1" If the answer is Yes, then its a No response in SC scenario and following actions need to be applied.
    
        #If a public/private comment added in the last hour
        if hours_elapsed_lastcomment < 1:
            SC_Status = "There is no response in SC. However, a potentially meaningful public/private comment was added in the last hour. It has been two weeks since we received a reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
            global_gpt_reply = "No GPT call made"
                      
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            
            put_ticket_on_open(credentials, ticket_number)
            remove_sc_esc_tag(credentials, ticket_number)
            add_tempo_unsuspend_tag(credentials, ticket_number)
            
        #If no public/private comment added in the last hour. This means timer or somethinr else opened the ticket.
        if hours_elapsed_lastcomment >= 1:
            #Something other than the timer opened the ticket like a SC reply from Support
            if hours_elapsed < default_hold_hours: 
                hold_value = default_hold_hours
                SC_Status = f"There is no response in SC. However, it has been less than {default_hold_hours} hours as previously put on hold but the ticket got open. I also noticed that this ticket has {ticket_priority} priority. I am decising to put the ticket on hold for another {default_hold_hours} hours."
                onhold_reason = f"SC Automation - No Response in SC but it has been less than {default_hold_hours} hours"

                print_action_IN(credentials, SC_Status, ticket_number)
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                
                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
            
            #Timer Opened the ticket
            if hours_elapsed >= default_hold_hours and brand_id != 360002486020: #If hours_elapsed > default hours and it is not CallStream Support, then put the ticket on hold for hours_elapsed-12 hours with a reply in SC
                if hours_elapsed > 336:
                    SC_Status = "It has been two weeks since we received a reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent to see if it should be closed."
                                    
                    print_action_IN(credentials, SC_Status, ticket_number)
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                    
                    put_ticket_on_open(credentials, ticket_number)
                    remove_sc_esc_tag(credentials, ticket_number)
                    add_tempo_unsuspend_tag(credentials, ticket_number)
                else:
                    hold_value = default_hold_hours
                    SC_Status = f"There has been no response in SC since the last hold of {default_hold_hours} hours. I also noticed that this ticket has {ticket_priority} priority. Therefore, I am sending a follow-up in SC and putting the ticket on hold for another {default_hold_hours} hours."
                    onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - Follow up in SC"
                    sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                    
                    add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                    reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                    remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                    
                    print_action_IN(credentials, SC_Status, ticket_number)
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                    
                    put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)

            #Timer Opened the ticket and ticket_brand = "CallStream Support":
            if hours_elapsed >= default_hold_hours and brand_id == 360002486020:
                filename = "GPT_Call_Stream_No_Response.txt"
                call_gpt(filename)
                global_gpt_reply = call_gpt(filename)
                print(global_gpt_reply)
                            
                if global_gpt_reply == "NO":
                    SC_Status = f"There has been no response in SC. This is CallStream and it has been {default_hold_hours} hours since the last hold. I also noticed that this ticket has {ticket_priority} priority. So, I engaged GPT to determine if a follow-up is needed but GPT answered, no. Therefore, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                    
                    print_action_IN(credentials, SC_Status, ticket_number)
                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                    
                    put_ticket_on_open(credentials, ticket_number)
                    remove_sc_esc_tag(credentials, ticket_number)
                    add_tempo_unsuspend_tag(credentials, ticket_number)

                if global_gpt_reply == "YES":
                    if hours_elapsed > 336:
                        SC_Status = "It has been two weeks since a reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review to see if the ticket should be closed"
                                     
                        print_action_IN(credentials, SC_Status, ticket_number)
                        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                        
                        put_ticket_on_open(credentials, ticket_number)
                        remove_sc_esc_tag(credentials, ticket_number)
                        add_tempo_unsuspend_tag(credentials, ticket_number)
                    else:
                        SC_Status = f"There is no response in SC. This is CallStream and it has been {default_hold_hours} hours since last hold. I also noticed that this ticket has {ticket_priority} priority. So I engaged GPT to determine if a follow up is needed. GPT answered, yes. Therefore, I am following up in SC and putting this ticket on hold for another {default_hold_hours} hours."
                        hold_value = default_hold_hours
                        onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - CallStream Support"
                        sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                        
                        add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                        reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                        remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                    
                        print_action_IN(credentials, SC_Status, ticket_number)
                        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                        
                        put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)
            
    # Check if the last Message in SC is MEANGINGLESS/MEANINGFULL 
    if hours_elapsed <= 1:
        filename = "GPT_Prompt_05.txt"
        call_gpt(filename)
        global_gpt_reply = call_gpt(filename)
        print(global_gpt_reply)

        if "MEANINGLESS" in global_gpt_reply:
            hold_value = default_hold_hours
            SC_Status = f"There is a meaningless reply in SC. I see that this ticket has {ticket_priority} priority. Given the previous history, I am putting the ticket on hold for {default_hold_hours} hours."
            onhold_reason = f"SC Automation - Meaningless Response in SC , putting back on for {default_hold_hours} hours"
            
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            
            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number)

        if "MEANINGFUL" in global_gpt_reply:
            SC_Status = "There is a meaningful reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
            
            print_action_IN(credentials, SC_Status, ticket_number)
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            
            put_ticket_on_open(credentials, ticket_number)
            remove_sc_esc_tag(credentials, ticket_number)
            add_tempo_unsuspend_tag(credentials, ticket_number)
