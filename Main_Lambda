import re
import requests
import os
import openai
from dotenv import load_dotenv
import json
from openai import OpenAI
import gspread
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread

#Authentication
OPENAI_API_KEY = 
ZENDESK_API_KEY = 

#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ'
SHEET_NAME = 'SCAutomationLog'
CREDENTIALS_FILE = 'gssecret001.json'
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):
    try:
        #### FUNCTIONS ####
        #Function to reply in SC
        def reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization" : f"Basic {credentials}"
            }

            jsonBody = {
                "message": {
                    "body": str(sc_reply),
                    "to": [
                        {"email": email} for email in recipients
                        #{ "email": "sh136708@gmail.com" },
                        #{ "email": "shfreelance@gmail.com" }
                    ]
                }
            }

            response = requests.request(
                "POST",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/reply",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                print("POST API for sending SC succeeded")
            else:
                print(f"POST API for sending SC failed: {response.status_code}")
        
        #Function to Put the Ticket On-Hold
        def put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number,SC_Status):
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Basic {credentials}"
            }
            
            jsonBody = {
                "ticket": {
                    "custom_fields": [
                        {"id": 360006442913, "value": "true"},
                        {"id": 360005123419, "value": str(hold_value)},
                        {"id": 360004438434, "value": str(onhold_reason)}
                    ],
                    "add_tags": ["alp_data_structure_link"],
                    "remove_tags": [
                        "onhold_eta_expired", "offset_added_onhold", "progress_report_no_progress", 
                        "active-chat", "atlas-ticket-custom-closure"
                    ],
                    "status": "hold",
                    "comment": {
                        "body": f"SC Automan: {SC_Status}\n",
                        "public": False
                    }
                }
            }
            
            #update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}"
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}" 
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                print("PUT API for putting the ticket on-hold succeeded")
            else:
                print(f"PUT API for putting the ticket on-hold failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")

        # Get the last INBOUND message text in SC Data
        def find_body_after_last_response_time(last_response_time):
            for event in filtered_sc_data["events"]:
                # Check if the 'created_at' matches the target date
                if event["created_at"] == last_response_time:
                    # If a match is found, print the 'body' from the 'message'
                    return event['message']['body']
            # If no match is found, return the specified message
            return "No inbound message in SC. The last response time is for the first outbound reply."
                        
        #Function to Call GPT
        def call_gpt(filename):
            #clean sc_data
            #sc_data_clean = json.dumps(sc_data, indent=4)
        
            #write sc_data_clean to a json file "sc_data_output.json"
            # with open('sc_data_output.json', 'w') as f:
            #     f.write(sc_data_clean)

            #data = json.loads(sc_data_clean)

            # Prompt GPT
            current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
            filepath = os.path.join(current_dir, filename)
            with open(filepath, 'r') as file:
                prompt = file.read().replace("last_response_text", last_response_text)
                gptresponse = client.chat.completions.create(
                    model="gpt-4", #"gpt-4-turbo"
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant."},
                        {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                    ],
                    max_tokens=2000
                )
                gpt_reply = gptresponse.choices[0].message.content
                return gpt_reply
                #print("GPT Verdict:", gpt_reply)
        
        #Function to add atlas-ticket-sc-dont-wakeup tag
        def add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization" : f"Basic {credentials}"
            }

            jsonBody = {                   
                "tags": ["atlas-ticket-sc-dont-wakeup"]   
            }

            response = requests.request(
                "PUT",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                print("PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
            else:
                print(f"PUT API for adding atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")

        #Function to remove atlas-ticket-sc-dont-wakeup tag
        def remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number):
            headers = {
                "Content-Type": "application/json",
                "Authorization" : f"Basic {credentials}"
            }

            jsonBody = {                   
                "tags": ["atlas-ticket-sc-dont-wakeup"]   
            }

            response = requests.request(
                "DELETE",
                f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/tags",
                headers=headers,
                data=json.dumps(jsonBody)
            )
            
            if response.status_code == 200:
                print("PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket succeeded")
            else:
                print(f"PUT API for removing atlas-ticket-sc-dont-wakeup tag on the ticket failed: {response.status_code}")
        
        #Function to write to GSHEET
        def write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply):
            gc = gspread.authorize(gscredentials)
            sh = gc.open_by_key('1fyju79jKHCDI7C2YAv-QbrqUnZ0g1sNccLuvao0o_AQ')
            worksheet = sh.worksheet('Sheet1')
            row_data = [current_time, ticket_number, ticket_brand, global_gpt_reply, SC_Status]
            worksheet.append_row(row_data)
        
        #Function to Make the ticket Open
        def put_ticket_on_open(credentials, ticket_number,SC_Status):
            headers = {
                "Content-Type": "application/json",
                "Authorization" : f"Basic {credentials}"
            }

            jsonBody = {
                "ticket": {
                    "status": "open",
                    "comment": {
                        "body": f"SC Automan: {SC_Status}\n",
                        "public": False
                    },
                    "additional_tags": ["tempo_unsuspend"],
                    "remove_tags": ["sc_esc"]
                }
            }
            
            update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
            update_response = requests.put(update_url, headers=headers, json=jsonBody)
            
            if update_response.status_code == 200:
                print("PUT API for opening the ticket succeeded")
            else:
                print(f"PUT API for opening the ticket failed: {update_response.status_code}")
                print(f"Response content: {update_response.content}")
                
        #### INITIALIZATION ####
                
        # Parse the incoming JSON payload
        if 'body' in event:
            body = json.loads(event['body'])
            ticket_number = body.get('ticket_number')
            print('Ticket Number:', ticket_number)
            if ticket_number is None:
                return {
                    'statusCode': 400,
                    'body': json.dumps('No ticket_number provided in the request body.')
                }
        else:
            return {
                'statusCode': 400,
                'body': json.dumps('No ticket_number provided in the request body.')
            }

        #Initialize variables
        global_gpt_reply = "No GPT call made"

        # Create a session and authenticate with basic auth
        session = requests.Session()
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        session.headers = {
            'Authorization':  f"Basic {credentials}"
        }

        # Make a GET request to retrieve the ticket Brand and Ticket Priority
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
        
        if response.status_code == 200:
            ticket_gen_data = response.json()
        else:
            print(f"Failed to fetch sc data: {response.status_code}")
        
        # Find the brand_id field
        brand_id = ticket_gen_data['ticket'].get('brand_id', None)
        
        #print('Brand ID:', brand_id)
        if brand_id == 360002486020:
            ticket_brand = "CallStream"
        elif brand_id == 360001065314:
            ticket_brand = "Symphony Commerce"
        elif brand_id == 8841502249362:
            ticket_brand = "Central Finance"
        elif brand_id == 360002499439:
            ticket_brand = "CityNumbers"
        else:
            ticket_brand = brand_id

        print("Ticket Brand:", ticket_brand)

        ticket_priority = ticket_gen_data['ticket'].get('priority', None)
        print("Ticket Priority:", ticket_priority)

        #Determine Current Time
        current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
        current_time_str = ''.join(current_time) # Convert the current time to a string
        current_time_new = datetime.fromisoformat(current_time_str.strip('Z')).replace(microsecond=0)
        print('Current Time:', current_time_new)
        # Make a GET request to retrieve the ticket SC details
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations')
        
        # Check if the request was successful and retrive SC data
        if response.status_code == 200:
            ticket_data_sc_list = response.json()
        else:
            print(f"Failed to fetch sc_list data: {response.status_code}")

        # Check if open SCs on the ticket are not one
        open_sc_count = sum(sc['state'] == 'open' for sc in ticket_data_sc_list['side_conversations'])
        if open_sc_count != 1:
            SC_Status = "I'm not taking any action on the ticket because it has more than one open SC. If we're not waiting on an SC, please mark it as 'done' so that I can handle it! Also, I'll leave the ticket open, remove the sc_esc tag, and add the tempo_unsuspend tag for an agent to manually review."
            global_gpt_reply = "No GPT call made. More than one open SC found."
            
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            put_ticket_on_open(credentials, ticket_number,SC_Status)
            return
        else:
            SC_Status = "SC Automan: One open SC was found, so I will work further on the ticket"
            sc_id = ticket_data_sc_list['side_conversations'][0]['id']
            sc_list = json.dumps(ticket_data_sc_list['side_conversations'], indent=4)
            print(SC_Status)
            print('SC ID:', sc_id)
        
        # Make a GET request to retrieve the ticket SC That's Open
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/side_conversations/{sc_id}/events')    

        # Check if the request was successful, retrive Open SC data and Clean it
        if response.status_code == 200:
            sc_data = response.json()
        else:
            print(f"Failed to fetch open sc events: {response.status_code}")
            
        # Filtering out all outbound email events So we are only looking at inbound emails in SC
        filtered_sc_data_outbound = {
            "events": [
                event for event in sc_data["events"]
                if event.get("message") and "external_ids" in event["message"] and "outboundEmail" in event["message"]["external_ids"]
            ]
        }

        filtered_sc_data = {
            "events": [
                event for event in sc_data["events"]
                if event.get("message") and "external_ids" in event["message"] and "inboundEmail" in event["message"]["external_ids"]
            ]
        }
        
        #Last Outbound Response Time in SC For Safety to Prevent Multiple Replies
        SC_automation_reply_events = [
            event['created_at'] for event in filtered_sc_data_outbound["events"]
            if event.get('actor') and 'email' in event['actor'] and event['actor']['email'] == 'ai-zd-integration@trilogy.com'
        ]

        if SC_automation_reply_events:  # Check if the list is not empty
            last_outbound_response_time_SC_Automan = SC_automation_reply_events[-1]
            print('Last Outbound Response Time by SC Automan:', last_outbound_response_time_SC_Automan)
            last_outbound_response_time_SC_Automan_new = datetime.fromisoformat(last_outbound_response_time_SC_Automan.strip('Z'))
            seconds_elapsed_last_outbound_response_SC_Automan = round((current_time_new - last_outbound_response_time_SC_Automan_new).total_seconds())
        else:
            last_outbound_response_time_SC_Automan = None
            seconds_elapsed_last_outbound_response_SC_Automan = None
            print('No previous replies by SC Automan found in the entire open SC.')
                
        #Determine Seconds Since Last Outbound Response by AC Automation
        print('Seconds Elapsed Since Last Outbound Response by SC Automan:', seconds_elapsed_last_outbound_response_SC_Automan)

        # Identify the time of the last event in the SC
        if not filtered_sc_data or not filtered_sc_data["events"]:
            last_response_time = filtered_sc_data_outbound["events"][0]['created_at']
        else:
            last_response_time = filtered_sc_data["events"][-1]['created_at']
        print('Last response time:', last_response_time)

        # Initialize an empty list to hold the recipient email addresses
        recipients = []

        # Iterate through the events to find the event with the matching 'created_at' time
        for event in sc_data['events']:
            if event['created_at'] == last_response_time:

                # Add the 'from' email address to the list of recipients
                recipients.append(event['message']['from']['email'])
                
                # Iterate through the 'to' list in the message of the matching event
                for to_user in event['message']['to']:
                    recipients.append(to_user['email'])
        
        # Remove Automation Sender ai-zd-integration@trilogy.com from recipients = []
        recipients = [recipient for recipient in recipients if recipient != 'ai-zd-integration@trilogy.com']

        # # Print all recipients
        # for idx, recipient in enumerate(recipients, start=1):
        #     print(f"last_response_recipient_{idx} = {recipient}")
        
        #create last_recepients as text string with all emails addresses of recipients in recipients separated by comma and a space
        last_recepients = ', '.join(recipients)
        print('Last Recipients:', last_recepients)

        #Determine hours elapsed since the last response
        last_response_time_str = ''.join(last_response_time)
        last_response_time_new = datetime.fromisoformat(last_response_time_str.strip('Z'))
        time_difference = current_time_new - last_response_time_new
        hours_elapsed = round(time_difference.total_seconds() / 3600, 2)
        print('Hours elapsed:', hours_elapsed)
        
        #Make a Get Request to get the ticket comments
        headers = {
            "Content-Type": "application/json",
            "Authorization" : f"Basic {credentials}"
        }

        response = requests.request(
            "GET",
            f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}/comments?sort_order=desc",
            headers=headers
        )

        # Check if the request was successful, retrieve comments data and Clean it
        if response.status_code == 200:
            comments_data = response.json()
        else:
            print(f"Failed to fetch ticket comments: {response.status_code}")

        # Find the default hold hours based on last hold or the ticket priority
        default_hold_hours = 0
        for comment in comments_data['comments']:
            if comment['author_id'] == 361576897454 and "Ticket set to ON-HOLD for" in comment['body']:
                # Extract the number of hours using regex
                match = re.search(r"Ticket set to ON-HOLD for (\d+)", comment['body'])
                if match:
                    default_hold_hours = int(match.group(1))
                    break

        if default_hold_hours == 0:
            if ticket_priority == 'urgent':
                default_hold_hours = 12
            elif ticket_priority == 'high':
                default_hold_hours = 24
            else:
                default_hold_hours = 72

        print("Default Hours Value", default_hold_hours)
        
        #In comments_data find "Created_at" value of first comment going from top to bottom added by Author ID 14181031764242 with Text "I see that the last response in the SC, less than 3 minutes ago, was from me (SC Automan)"
        for comment in comments_data['comments']:
            if comment['author_id'] == 14181031764242 and "I see that the last response in the SC, less than 3 minutes ago, was from me (SC Automan)" in comment['body']:
                last_sc_automan_3min_in_time = comment['created_at']
                break
        last_sc_automan_3min_in_time_new = datetime.fromisoformat(last_sc_automan_3min_in_time.strip('Z'))
        seconds_elapsed_last_sc_automan_3min_in = round((current_time_new - last_sc_automan_3min_in_time_new).total_seconds())
        
        ##Identify the time of the last meaningful comment in the ticket
        
        #List of author IDs to exclude. There are integeration users like Alen and CSAI that we want to exclude
        exclude_author_ids = {'1905297657594', '14181031764242', '10873686477458', '361576897454', '362463859613'}
        #Filtering comments to exclude those made by the specified author IDs
        filtered_comments = [comment for comment in comments_data['comments'] if str(comment['author_id']) not in exclude_author_ids or "JiraStatusChanged" in comment['body'] or "Ticket was reopened" in comment['body']]
        
        #Last Meaningful comment time
        last_comment_time = filtered_comments[0]['created_at']
        print('Last comment time:', last_comment_time)
        
        #Determine hours elapsed since the last comment
        last_comment_time_str = ''.join(last_comment_time)
        last_comment_time_new = datetime.fromisoformat(last_comment_time_str.strip('Z'))
        print('Last comment time_new:', last_comment_time_new)
        time_difference_comment = current_time_new - last_comment_time_new
        print('current_time_new:', current_time_new)
        print('Time difference:', time_difference_comment)
        hours_elapsed_lastcomment = round(time_difference_comment.total_seconds() / 3600, 2)
        print('Hours elapsed since last comment:', hours_elapsed_lastcomment)
        
        #Determine the last response text in SC
        last_response_text_unclipped = find_body_after_last_response_time(last_response_time)
        #Enable this Line with a long SC reply to test Lamda exceptions by recreating exceeding token limit #last_response_text = last_response_text_unclipped
        last_response_text = last_response_text_unclipped[:1000] # Clip the text to 1000 characters to avoid GPT token limit
        print('Last message in SC:', last_response_text)
            
        #### LOGIC ####

        # Check if the last Message in SC is MEANGINGLESS/MEANINGFULL 
        if hours_elapsed <= 1 and last_response_text != "No inbound message in SC. The last response time is for the first outbound reply.":
            filename = "GPT_Prompt_05.txt"
            global_gpt_reply = call_gpt(filename)
            print(global_gpt_reply)

            if "MEANINGLESS" in global_gpt_reply:
                hold_value = default_hold_hours
                SC_Status = f"There is a meaningless reply in SC. I see that this ticket has {ticket_priority} priority. Given the previous history, I am putting the ticket on hold for {default_hold_hours} hours."
                onhold_reason = f"SC Automation - Meaningless Response in SC, putting back on for {default_hold_hours} hours"
                
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)

            if "MEANINGFUL" in global_gpt_reply:
                SC_Status = "There is a meaningful reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                put_ticket_on_open(credentials, ticket_number, SC_Status)
        
        elif hours_elapsed <= 1 and last_response_text == "No inbound message in SC. The last response time is for the first outbound reply.":
            hold_value = default_hold_hours
            SC_Status = "There is no response in SC and it looks like we never received any response to date. Given that the last response sent by us was less than hour ago, I am putting the ticket on hold for {default_hold_hours} hours."
            onhold_reason = f"SC Automation - No Response in SC to date, putting back on for {default_hold_hours} hours"
            
            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)
        
        # Check if the last Activity in SC is a No response scenario
        elif hours_elapsed > 1:
        
            # If a public/private comment added in the last hour
            if hours_elapsed_lastcomment < 1:
                SC_Status = "There is no response in SC. However, a potentially meaningful public/private comment was added in the last hour. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                global_gpt_reply = "No GPT call made"
                        
                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                put_ticket_on_open(credentials, ticket_number, SC_Status)
                
            # If no public/private comment added in the last hour. This means timer or something else opened the ticket.
            elif hours_elapsed_lastcomment >= 1:
                # Something other than the timer opened the ticket like a SC reply from Support
                if hours_elapsed < default_hold_hours: 
                    hold_value = default_hold_hours
                    SC_Status = f"There is no response in SC. However, it has been less than {default_hold_hours} hours as previously put on hold. I also noticed that this ticket has {ticket_priority} priority. I am deciding to put the ticket on hold for another {default_hold_hours} hours."
                    onhold_reason = f"SC Automation - No Response in SC but it has been less than {default_hold_hours} hours"

                    write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                    put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)
                
                # Timer Opened the ticket
                elif hours_elapsed >= default_hold_hours and brand_id != 360002486020:
                    if hours_elapsed > 240:
                        SC_Status = "It has been 10 days since we received a reply in SC. So, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent to see if it should be closed."
                                        
                        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                        put_ticket_on_open(credentials, ticket_number, SC_Status)
                    else:
                        if filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180 and seconds_elapsed_last_sc_automan_3min_in <= 180:
                            SC_Status = "It seems like I'm being called in a loop! So I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                            put_ticket_on_open(credentials, ticket_number, SC_Status)
                            
                        elif filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180:
                            SC_Status = "I see that the last response in the SC, less than 3 minutes ago, was from me (SC Automan). So I am refraining from sending any more response in SC and putting the ticket on-hold without a reply."
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                            onhold_reason = f"SC Automation - No Response in SC, putting back on for {default_hold_hours} hours"
                            hold_value = default_hold_hours
                            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)
                            
                        else:
                            hold_value = default_hold_hours
                            SC_Status = f"There has been no response in SC since the last hold of {default_hold_hours} hours. I also noticed that this ticket has {ticket_priority} priority. Therefore, I am sending a follow-up in SC and putting the ticket on hold for another {default_hold_hours} hours."
                            onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - Follow up in SC"
                            sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                            
                            add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                            reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                            remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                            
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                            put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)

                # Timer Opened the ticket and ticket_brand = "CallStream Support"
                if hours_elapsed >= default_hold_hours and brand_id == 360002486020:
                    filename = "GPT_Call_Stream_No_Response.txt"
                    global_gpt_reply = call_gpt(filename)
                    print(global_gpt_reply)
                                
                    if global_gpt_reply == "NO":
                        SC_Status = f"There has been no response in SC. This is CallStream and it has been {default_hold_hours} hours since the last hold. I also noticed that this ticket has {ticket_priority} priority. So, I engaged GPT to determine if a follow-up is needed but GPT answered, no. Therefore, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                        
                        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                        put_ticket_on_open(credentials, ticket_number, SC_Status)

                    elif global_gpt_reply == "YES":
                        if hours_elapsed > 336:
                            SC_Status = "It has been two weeks since a reply in SC. I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent to see if the ticket should be closed"
                                        
                            write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                            put_ticket_on_open(credentials, ticket_number, SC_Status)
                        else:
                            if filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180 and seconds_elapsed_last_sc_automan_3min_in <= 180:
                                SC_Status = "It seems like I'm being called in a loop! So I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
                                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                                put_ticket_on_open(credentials, ticket_number, SC_Status)
                                
                            elif filtered_sc_data_outbound["events"][-1]['message']['from']['email'] == 'ai-zd-integration@trilogy.com' and seconds_elapsed_last_outbound_response_SC_Automan <= 180:
                                SC_Status = "I see that the last response in the SC, less than 30 seconds ago, was from me (SC Automan). So I am refraining from sending any more response in SC and putting the ticket on-hold without a reply."
                                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                                put_ticket_on_open(credentials, ticket_number, SC_Status)
                                
                            else:
                                SC_Status = f"There is no response in SC. This is CallStream and it has been {default_hold_hours} hours since last hold. I also noticed that this ticket has {ticket_priority} priority. So I engaged GPT to determine if a follow up is needed. GPT answered, yes. Therefore, I am following up in SC and putting this ticket on hold for another {default_hold_hours} hours."
                                hold_value = default_hold_hours
                                onhold_reason = f"SC Automation - No Response in SC in {default_hold_hours} hours - CallStream Support"
                                sc_reply = f"Dear Team,\n\nWe are eagerly awaiting your response. Please provide an update at your earliest convenience.\n\nThank you."
                                
                                add_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                                reply_in_SC(credentials, recipients, sc_reply, sc_id, ticket_number)
                                remove_atlas_ticket_sc_dont_wakeup_tag(credentials, ticket_number)
                        
                                write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
                                put_ticket_on_hold(credentials, hold_value, onhold_reason, ticket_number, SC_Status)
            
    except Exception as e:
        print(f"Lamda exception occurred: {str(e)}")
        SC_Status = "I encountered a bit of a snag! So, I am leaving the ticket open, removing the sc_esc tag and adding the tempo_unsuspend tag for a manual review by an agent."
        write_to_gsheet(gscredentials, current_time, ticket_number, ticket_brand, SC_Status, global_gpt_reply)
        put_ticket_on_open(credentials, ticket_number,SC_Status)
